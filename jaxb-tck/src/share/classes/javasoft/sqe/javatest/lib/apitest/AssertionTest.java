/*
 * Copyright (c) 2002, 2020 Oracle and/or its affiliates. All rights reserved.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0, which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the
 * Eclipse Public License v. 2.0 are satisfied: GNU General Public License,
 * version 2 with the GNU Classpath Exception, which is available at
 * https://www.gnu.org/software/classpath/license.html.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0
 *
 * */

package javasoft.sqe.javatest.lib.apitest;

import java.lang.reflect.*;
import java.util.Vector;
import java.util.StringTokenizer;
import javasoft.sqe.javatest.Status;
import javasoft.sqe.javatest.Test;
import java.io.PrintWriter;
import java.io.PrintStream;
import java.io.OutputStream;

/**
 * This class is the kernel of AssertionTest which is responsible
 * for executing a method or a constructor under test using the
 * parameters generated by the Generator object and reporting the
 * results to the Reporter object. 
 * 
 * @author Rampalli Narasimhan, Jonathan Gibbons, Kevin A Smith
 * @see    Generator
 * @see    Reporter
 * @see    Factory
 */

//
// Unfortunately for the time being we are forced to support some amount 
// of backwards compatibility. Hence AssertionTest needs to implement 
// two different Test interfaces. This will go away in a short while.
//
public abstract class AssertionTest implements javasoft.sqe.javatest.Test, javasoft.sqe.harness.Test {
    /**
     * This method is responsible for initiating the testing process.
     * This method does the following tasks
     * <OL>
     * <LI> Initialize the PrintWriters log and ref
     * <LI> Call init(), decodeAllArgs() etc to decode command line arguments
     * <LI> Do some preliminary checks to see if the method under test
     *      or constructor under test is set correctly.
     * <LI> Start off the reporting process.
     * <LI> Start the test process by passing the data factories to the Generator
     *      object (which will create test points and execute those test points
     *      by calling back AssertionTest.runTest()). When the Generator completes
     *      it returns control to this method by returning the overall test status.
     * <LI> Complete the reporting process using the overall test status.
     * </OL>
     * 
     * @param args Arguments passed at runtime
     * @param log  PrintWriter to write the log information.
     * @param ref  PrintWriter to write the reference information.
     * 
     */
    public Status run(String args[], PrintWriter log, PrintWriter ref) {
	this.log = log;
	this.ref = ref;
	//
	// decodeArgs tries to decode all the arguments passed to AssertionTest
	// and init will create a new Generator and Reporter based on the param
	// passed at runtime.
	//
	try {
	    decodeAllArgs(args);
	    init();
	}
	catch (Fault f) {
	    return Status.failed (f.getMessage());
	}
	if (methodTest) {
	    reporter.reportTestStart (methodUnderTest, dataFactories);
	}
	else {
	    reporter.reportTestStart (constructorUnderTest, dataFactories);
	}
	Status testStat = generator.run(this, dataFactories);
	reporter.reportTestDone(testStat);
	return testStat;      
    } 


    //
    // Support for Backward Compatibility
    //
    public javasoft.sqe.harness.Status run (String[] args, PrintStream log, PrintStream ref) {
	OutputStream osLog = log;
	PrintWriter pwLog = new PrintWriter (osLog);
	OutputStream osRef = ref;
	PrintWriter pwRef = new PrintWriter (osRef);
	javasoft.sqe.javatest.Status testStat = run (args, pwLog, pwRef);
	javasoft.sqe.harness.Status thisTestStatus;
	pwLog.flush();
	pwRef.flush();
	if (testStat.getType() == javasoft.sqe.javatest.Status.PASSED) {
	    thisTestStatus = javasoft.sqe.harness.Status.passed ("Test Passed");
	} else {
	    thisTestStatus = javasoft.sqe.harness.Status.failed ("Test Failed");
	}
	return thisTestStatus;
    }

    /**
     * <P>
     * The <CODE>run</CODE> method calls this method for decoding the
     * arguments passed to this program at run time. The purpose of
     * decodeAllArgs is to call the method decodeArgs to decode the
     * arguments and since decodeArgs is a protected method a test 
     * developer can redefine the method according to his/her requirements.
     * </P>
     * @param args An array of strings passed as parameter at runtime.
     * @exception Fault raised when an unrecognized parameter is passed at runtime.
     *
     */
    protected final void decodeAllArgs(String[] args) throws Fault {
	for (int i = 0; i < args.length; ) {
	    int j  = decodeArg(args, i);
	    if (j == 0) {
		throw new Fault("Argument Unrecognized: " + args[i]);
	    }
	    i += j;
	}
    }

    /**
     * This method creates the Reporter and Generator objects that
     * are used by AssertionTest to complete the test process. If
     * the Reporter/Generator objects are passed to this method at
     * runtime, then this method will use those values to create the
     * appropriate Reporter and Generator objects. By default this 
     * method will create the PrintReporter and GridGenerator objects.
     * 
     * @exception Fault raised when there is an error in creating the 
     *                  generator or reporter.
     */
    protected void init () throws Fault {
	try {
	    createReporter (reporterClassName);
	    createGenerator (generatorClassName);
	}
	catch (Fault f) {
	    throw new Fault (f.getMessage());
	}
    }


    /**
     * The purpose of this method is to decode the set of arguments that
     * are given to AssertionTest at runtime. AssertionTest takes two
     * different sets of arguments. They are 
     * <OL>
     * <LI> <CODE>-reporter ReporterClassName ReporterArguments -end</CODE>
     * <LI> <CODE>-generator GeneratorClassName GeneratorArguments -end</CODE>
     * </OL>
     * The test writer may override this method to process his/her own set of
     * arguments.
     *
     * @param args Command line arguments
     * @param i    index of the argument
     * @exception Fault raised when there is an error while decoding arguments.
     */
    protected int decodeArg (String[] args, int j) throws Fault {
	int i = j;
	if (args[i].equals("-generator")) {
	    Vector genArgs = new Vector();
	    generatorClassName = args[++i];
	    try {
		while (!args[++i].equals("-end")) {
		    genArgs.addElement(args[i]);
		} 
	    }
	    catch (ArrayIndexOutOfBoundsException a) {
		throw new Fault ("There is no -end to the generator parameter list");
	    }
	    i += 1; // Go to the next command line argument
	    generatorArgs = new String[genArgs.size()];
	    genArgs.copyInto (generatorArgs);
	}
	else if (args[i].equals("-reporter")) {
	    Vector repArgs = new Vector();
	    reporterClassName = args[++i];
	    try {
		while (!args[++i].equals("-end")) {
		    repArgs.addElement(args[i]);
		}
	    }
	    catch (ArrayIndexOutOfBoundsException a) {
		throw new Fault ("There is no -end to the reporter parameter list");
	    }
	    i += 1; // Go to the next command line argument
	    reporterArgs = new String[repArgs.size()];
	    repArgs.copyInto (reporterArgs);
	}
	else {
	    return 0;
	} 
	return i - j;
    }


    /*
     * This method creates a Generator object and by default creates a 
     * GridGenerator object.
     */
    private void createGenerator (String s) throws Fault {
	if (s != null) {
	    try {
		Class c =  Class.forName(s);
		if (!(Generator.class).isAssignableFrom (c)) {
		    throw new Fault ("This is not a valid generator class");
		}
		generator =  (Generator) c.newInstance();
	    }
	    catch (ClassNotFoundException e) {
		throw new Fault (e.toString());
	    }
	    catch (IllegalAccessException i) {
		throw new Fault (i.toString());
	    }
	    catch (InstantiationException ie) {
		throw new Fault (ie.toString());
	    }
	}
	else {
	    generator = new GridGenerator();
	}
	generator.init(generatorArgs);
    }

    /*
     * This method creates a Reporter object and by default creates a 
     * PrintReporter object.</P>
     */
    private void createReporter(String s) throws Fault {
	if (s != null) {
	    try {
		Class  c = Class.forName(s);
		if (!(Reporter.class).isAssignableFrom(c)) {
		    throw new Fault ("This is not a valid reporter class");
		}
		reporter = (Reporter) c.newInstance();
	    }
	    catch (ClassNotFoundException e) {
		throw new Fault (e.toString());
	    }
	    catch (IllegalAccessException i) {
		throw new Fault (i.toString());
	    }
	    catch (InstantiationException ie) {
		throw new Fault (ie.toString());
	    } 
	}
	else {
	    reporter = new PrintReporter();
	}
	reporter.init(reporterArgs, log, ref);
    }

    // -------------------------- END OF ALL INITIALIZATION METHODS -------------------
    // -------------------------- START ACTUAL TESTING CODE ---------------------------


    /**
     * This method executes the method under test or the constructor under test depending
     * upon the testcase.
     * 
     * This method takes 3 parameters - classInstance (null in case of a constructor test)
     * is the instance of the class on which the method is executed. exeParam is a set of
     * parameters for executing the method/constructor and a exeSignature that represents
     * the index in the Factory array (which is used for reporting purposes).
     * 
     * <p>This method functions as follows:
     * <UL>
     * <LI> First it calls savePreState() to do the setup operations (if any) before the method
     * (or constructor) is invoked.
     * <LI> Then it predicts the set of exceptions that this method is expected to raise
     * (null if this method does not raise any exception).
     * <LI> Then it performs a check on the expected exceptions - If the test developer
     * tries to predict an exception that will never be raised an error will be signalled
     * and further processing will be aborted.
     * <LI> The method/constructor under test will be executed.
     * <LI> Execution of method/constructor may raise an exception - If it is an exception
     * that is raised by invoke() or newInstance() [Reflections API used for invoking the
     * method under test or creating a new instance of the constructor], then the test will
     * flag an error and abort. If the exception was raised by executing this method 
     * or constructor, then the exception will be saved for further processing. Note a
     * method can execute without raising an exception also. Here are the various possiblities
     * <OL>
     * <LI><B>An exception was unexpected and was not raised</B><BR>
     *     The method executed correctly so far. However to flag the test pass, the post condition
     *     should be also correct. So this method will call normalPostCondition() to check
     *     the post condition. If the normalPostCondition check is OK, then this method will 
     *     call the postCondition() method (a set of conditions that should be true at all times).
     *     If the normalPostCondition() check is not OK, then the test <B>FAILED</B>.
     *     If postCondition() check is also OK, then the test <B>PASSED</B> or else the test 
     *     <B>FAILED</B>.
     * <LI><B>An exception was unexpected but was raised</B><BR>
     *     Clearly the test <B>FAILED</B>.
     * <LI><B>An exception was expected but was not raised</B><BR>
     *     Clearly the test <B>FAILED</B>
     * <LI><B>An exception was expected and an exception was raised</B><BR>
     *     The test is considered <B>PASSED</B> if and only if the exception raised was the 
     *     exception expected and both - exceptionPostCondition() and postCondition() are OK.
     * </OL>
     * </UL>
     *
     * @param objectUnderTest  The instance of the class
     * @param exeParameters    The execution parameter set
     * @param exeSignature     An array of integers that correspond to the Factory index
     *                         (used by the Reporter object) 
     *
     */
    public final Status runTest (Object objectUnderTest, Object[] exeParameters, int[] exeSignature) {

	this.objectUnderTest = objectUnderTest;
	this.exeParameters = exeParameters;
	this.exeSignature = exeSignature;
	canAssertionBeChecked = false;
	didAssertionFail = false;
	Status testStat = Status.passed("Test Started");
 
	reporter.reportTestData (objectUnderTest, exeParameters, exeSignature);
	try {    
	    expectedExceptionSet = predictExceptionSet (exeParameters);
	    if (methodTest) 
		checkExceptionSet(expectedExceptionSet, methodUnderTest.getExceptionTypes());
	    else 
		checkExceptionSet(expectedExceptionSet, constructorUnderTest.getExceptionTypes());    
	    savePreState();
	    try {
		if (methodTest) {
		    result = methodUnderTest.invoke (objectUnderTest, exeParameters);
		}
		else {
		    result = constructorUnderTest.newInstance (exeParameters);
		}
		testStat = analyzeNormally ();
	    }
	    catch (InvocationTargetException t) {
		// this is where most expected exceptions get handled
		Throwable exceptionRaised = t.getTargetException();
		testStat = analyzeExceptionally(exceptionRaised);
	    } 
	    catch (Error e) {
		// as of JDK1.4, errors thrown from the reflection target
		// are not caught and wrapped in InvocationTargetException,
		// so we catch them here explicitly.
		testStat = analyzeExceptionally(e);
	    }
	    finally {
	      releasePreState();
	    }
	}
	catch (Fault fe) {
	    testStat = Status.failed (fe.getMessage());
	}
	catch (ThreadDeath td) {
	    reporter.reportException (td);
	    throw td;
	}
	catch (Throwable t) {
	    reporter.reportException (t);
	    testStat = Status.failed (t.toString() + " raised.");
	}
	reporter.reportTestResult(result, testStat);
	return testStat;
    }



    //
    // Test has executed normally without raising any exceptions. Check
    // to see 2 things
    // (a) Should the test raise an exception AND did not raise? If yes
    //     the test FAILED.
    // (b) OK no exception was expected but is the post conditions OK.
    //     If yes, then the test passed.
    //
    private Status analyzeNormally() throws Fault {
	if (expectedExceptionSet.size() == 0) {
	    try {
		canAssertionBeChecked = true;
		normalPostCondition();
		postCondition();
		canAssertionBeChecked = false;
		if (didAssertionFail) 
		    return Status.failed ("Assertions failed: All Assertions Checked");
		else  
		    return Status.passed ("Test Passed");
	    }
	    catch (Fault f) {
		throw new Fault(f.getMessage());
	    }
	}
	else {
	    return Status.failed ("An exception was expected but was not raised");
	}
    }

    //
    // Test did raise an exception. 
    // (a) Is the test expected to raise an exception? No, then the test FAILED.
    // (b) If yes then check  - (1) Is the right exception raised.
    //                          (2) Is the system post conditions OK
    // If the answer to questions (1) and (2) are YES then the test PASSED or else
    // the test failed.
    //
    private Status analyzeExceptionally(Throwable exception) throws Fault { 
	Throwable exceptionRaised = exception;
	if (expectedExceptionSet.size() == 0)  
	    return Status.failed ("Unexpected Exception: " + exceptionRaised.toString() + " raised");
	else {
	    if (expectedExceptionSet.contains(exceptionRaised)) {
		try {
		    ExpectedException[] e = expectedExceptionSet.getExceptionList(exceptionRaised);
		    canAssertionBeChecked = true;
		    for (int k = 0; k < e.length; k++) {
			e[k].exceptionPostCondition();
		    }
		    postCondition();
		    canAssertionBeChecked = false;
		    if (didAssertionFail) 
			return Status.failed("Assertions failed: All Assertions Checked");
		    else 
			return Status.passed ("Test Passed");
		}
		catch (Fault f) {
		    throw new Fault(f.getMessage());
		}
	    }
	    else { 
		return Status.failed ("Obtained Exception: " + exceptionRaised.toString() + 
				      " is NOT an expected exception.");
	    }
	}
    }

    //------------------------ END OF CODE THAT DOES THE ACTUAL TESTING -------------------

    //------------------------ START CODE for get....() methods ---------------------------

    /**
     * This method returns the method under test.
     */
    public Method getMethod() {
	return methodUnderTest;
    }

    /**
     * This method returns the constructor under test.
     */
    public Constructor getConstructor() {
	return constructorUnderTest;
    }

    //------------------------- END get...() methods / START assert() ------------------

    /**
     * This method is used for checking assertions after executing a method/constructor
     * under test. This method stops the testing process for that specific test point
     * when the first assertion check fails. This method can be executed only from 
     * <CODE>postCondition(), exceptionPostCondition(), normalPostCondition()</CODE>
     * methods. If a test developer tries to call this method from anywhere else this
     * method will raise the exception <CODE>Assertion.Fault</CODE>
     *
     * @param b the boolean expression tested
     * @param s the string associated with this assertion (a comment)
     * @exception Fault This exception is raised either when a call to hardAssert() fails
     *                  or when this method is invoked from a incorrect location.
     */  
    public void hardAssert(boolean b, String s) throws Fault  {
	if (canAssertionBeChecked) {
	    if (!b) {
		didAssertionFail = true;
		reporter.reportAssertion (s, b);
		throw new Fault("Assertion Failed");
	    }
	    reporter.reportAssertion (s, b);
	}
	else {
	    reporter.reportAssertion(s, b);
	    throw new Fault ("Assertion checked from a non-postCondition method");
	}
    }

    /**
     * This variant of assert can be used by the test developer when he/she
     * wants a test to continue even when an assertion check fails. This method
     * raises the exception AssertionTest.Fault if it is called from anywhere
     * else except the postCondition() methods.
     * 
     * @param b the boolean expression tested
     * @param s the string associated with this assertion (a comment)
     * @exception Fault  This exception is raised when softAssert 
     *            is invoked from a incorrect location.
     */  
    public void softAssert(boolean b, String s) throws Fault  {
	if (canAssertionBeChecked) {
	    if (!b) {
		didAssertionFail = true;
		reporter.reportAssertion (s, b);
	    }
	    reporter.reportAssertion (s, b);
	}
	else {
	    reporter.reportAssertion (s, b);
	    throw new Fault ("Assertion checked from a non-postCondition method");
	}
    }


    // ------------ END assert...() code/START constructors() ------------------

    /**
     * Constructor that takes no arguments. This constructor should be used
     * when the test developer sets the name of the method/constructor under
     * test by calling the set...() methods.
     */
    protected AssertionTest() {

    }


    /**
     * Constructor that takes a Method and the factory[] as
     * parameters. This should be called while testing a
     * method.
     *
     * @param methodObj Method under test
     * @param data An array of Factories that represent the test data.
     */
    protected AssertionTest (Method methodObj, Factory[] data) {
	methodUnderTest = methodObj;
	methodTest = true;
	dataFactories = data;
    }

    /**
     * Constructor that takes a Constructor and the factory[] as
     * parameters. This should be called while testing a
     * constructor.
     * 
     * @param constructorObj Constructor under test
     * @param data An array of Factories that represent the test data.
     */
    protected AssertionTest (Constructor constructorObj, Factory[] data) {
	methodTest = false;
	constructorUnderTest = constructorObj;
	dataFactories = data;
    }

    //----------------------- END OF CONSTRUCTORS ---------------------------

    //----------------------- BEGIN set....() methods -----------------------

    /**
     * This method is used for setting the method under test.
     * Use this method to set the method under test if and only if
     * this is a method test <b>and</b> if the test uses the default
     * AssertionTest constructor.
     * 
     * @param m the method under test
     * @exception Fault raised when this method is incorrectly used.
     */

    protected void setMethodUnderTest(Method m) throws Fault {
	if (methodUnderTest != null) {
	    throw new Fault("The method under test is already set.");
	}
	else if (constructorUnderTest != null) {
	    throw new Fault("A test can test a method or a constructor, but not both");
	}
	else {
	    methodTest = true;
	    methodUnderTest = m;
	}
    }

    /**
     * This method is used for setting the constructor under test.
     * Use this method to set the constructor under test if and only if
     * this is a constructor test <b>and</b> if the test uses the default
     * AssertionTest constructor.
     *
     * @param c the constructor under test
     * @exception Fault raised when this method is incorrectly used.
     */

    protected void setConstructorUnderTest(Constructor c) throws Fault {
	if (constructorUnderTest != null) {
	    throw new Fault("The constructor is already set.");
	}
	else if (methodUnderTest != null) {
	    throw new Fault("A test can test a method or a constructor, but not both");
	}
	else {
	    methodTest = false;
	    constructorUnderTest = c;
	}
    }

    /**
     * This method is used for setting the dataFactories.
     * Use this method to set the data factories if the test uses the default
     * AssertionTest constructor.
     *
     * @param f an array of data factories
     */

    protected void setDataFactories(Factory[] f) {
	dataFactories = f;
    }

    //----------------------------------- END OF set...() methods --------------


    /**
     * Any information that pertains to the state of the object under test
     * can be saved by the test developer by overriding this method. 
     * 
     * @exception Fault raised when an assertion check using hard/soft assert is placed here. 
     *
     */
    protected void savePreState() throws  Fault {
    }

    /**
     * The state information captured at <CODE>savePreState()</CODE> can
     * be released by overriding this method.  
     * 
     * @exception Fault raised when an assertion check using hard/soft assert is placed here.
     */
    protected void releasePreState() throws Fault {
    }

    /**
     * When a method/constructor under test is executed there may be some post conditions
     * that are applicable whether the method executed normally or if it raised an exception -
     * The purpose of this method is to place all those assertions here by overriding this
     * method.
     *
     *
     * @exception Fault raised when a hardAssert() fails within this method.
     */
    protected void postCondition() throws Fault {
    }

    /**
     * If a method is capable of raising an exception then a
     * test developer is expected to override this method by
     * predicting a set of exceptions that can be raised by
     * the method.
     * 
     * @param exeParam paramters used for executing method/constructor under test.
     */ 
    protected ExceptionSet predictExceptionSet(Object[] exeParam) {
	ExceptionSet e = new ExceptionSet();
	return e;
    }

    /**
     * This method is called when the method executed without raising an
     * exception <B>and</B> if the method is <b>not</b> expected to raise an exception
     * to check the post condition. AssertionTest based test developers
     * are expected to override this method and place some
     * assertions are checks to ensure that the method/constructor is 
     * executed correctly.
     *
     * @exception Fault will be raised by assert().
     *
     */
    protected void normalPostCondition() throws Fault {
    }

    /**
     * This method returns the value of the object under test if this test is 
     * a method test.
     *
     */
    protected Object getObjectUnderTest () {
	return objectUnderTest;
    }

    /**
     * This method returns an Object[] containing all the execution parameters that are
     * used for executing the method or constructor under test.
     */
    protected Object[] getExecutionParameters() {
	return exeParameters;
    }

    /**
     * This method returns the specific object that was used for executing
     * a method or constructor under test.
     * <B>BEWARE</B>
     * Sometimes a method or a constructor may not take any arguments at all.
     * 
     * @param index the index of the parameter requested
     */
    protected Object getExecutionParameter(int index) {
	if (index < exeParameters.length) {
	    return exeParameters[index];
	}
	else {
	    return null;
	} 
    }

    /**
     * This method returns the result obtained from executing either the
     * method or constructor under test.
     */
    protected Object getResult() {
	return result;
    }

 
    //------------------------------ HELPER METHODS --------------------------
    /**
     * This method is called to check if the test writer is trying
     * to predict only those exceptions that can be raised by this
     * method.
     * 
     * @param e the set of exceptions predicted by the test developer
     * @param methodExceptionSet the set of exceptions that can be thrown by the method/constructor
     * @exception AssertionTest.Fault raised when the test developer tries to catch an exception that
     *                                will never be raised.
     */
    private void checkExceptionSet(ExceptionSet e, Class[] methodExceptionSet) throws Fault {
    nextException:
	for (int i = 0; i < e.size(); ++i) {
	    ExpectedException ee = e.getException(i);
	    Class eeClass = ee.getExceptionClass();
	    for (int j = 0; j < methodExceptionSet.length; ++j) {
		if (methodExceptionSet[j].isAssignableFrom (eeClass)) {
		    continue nextException;
		}
	    }
	    if (((RuntimeException.class).isAssignableFrom (eeClass)) || 
		((Error.class).isAssignableFrom (eeClass))) {
		continue nextException;
	    }
	    throw new Fault (eeClass.getName());
	}
    }

    //----------------------------  END OF HELPER METHODS -------------------------------

    /**
     * The PrintWriter where log information is written.
     */
    protected PrintWriter log;

    /**
     * The PrintWriter where reference information is written.
     */
    protected PrintWriter ref;

    /**
     * <P>
     * The generator object used for generating the test data. This
     * object is protected because the method <CODE>run</CODE> may
     * be redefined by the test developer.
     * </P>
     */
    protected Generator generator;

    /**
     * <P>
     * The generator class name used for creating a generator object. This
     * object is protected because the method <CODE>decodeArgs</CODE> may
     * be redefined by the test developer.
     * </P>
     */
    protected String generatorClassName;

    /**
     * <P>
     * The generator arguments used for initializing a generator object. This
     * object is protected because the method <CODE>decodeArgs</CODE> may
     * be redefined by the test developer.
     * </P>
     */
    protected String[] generatorArgs;

    /**
     * <P>
     * The reporter class name used for creating a reporter object. This
     * object is protected because the method <CODE>decodeArgs</CODE> may
     * be redefined by the test developer.
     * </P>
     */
    protected String reporterClassName;

    /**
     * <P>
     * The reporter arguments used for initialising a reporter object. This
     * object is protected because the method <CODE>decodeArgs</CODE> may
     * be redefined by the test developer.
     * </P>
     */
    protected String[] reporterArgs;

    /**
     * <P>
     * The reporter object used for reporting the test results. This
     * object is protected because the method <CODE>run</CODE> may
     * be redefined by the test developer.
     * </P>
     */
    protected Reporter reporter;

    //
    // Private members used by runTest and other methods.
    //
    private Object objectUnderTest;
    private Method methodUnderTest;
    private Constructor constructorUnderTest;
    private Object[] exeParameters;
    private int[] exeSignature; 
    private Object result;
    private Factory[] dataFactories;
    private boolean canAssertionBeChecked;
    private boolean methodTest = true;
    private boolean didAssertionFail = false;
    private ExceptionSet expectedExceptionSet;

    /** 
     * This class implements the abstraction for an Expected Exception. 
     */
    public class ExpectedException {

	/**
	 * Constructor - construct an expected exception with an 
	 * Exception class type and a message associated with that
	 * exception (useful when the exception name is not good 
	 * enough to describe the exception.
	 */
	public ExpectedException(Class c, String mesg) {
	    message = mesg;
	    if (c != null) {
		if (!(Throwable.class).isAssignableFrom(c)) {
		    log.println ("Error:" + c.getName() + " is not a subclass of Throwable");
		    return; 
		}
	    }
	    exceptionClass = c;
	}

	/**
	 * Constructor - construct an expected exception with a class
	 * type.
	 *
	 * @param c The exception class.
	 */ 
	public ExpectedException(Class c) {
	    this (c, c.getName());
	}

	/**
	 * This method returns the class of the exception. It should be called
	 * getClass() as it returns a class type but getClass() is a final method
	 * in Object - so it is called getExceptionClass().
	 *
	 */
	public Class getExceptionClass() {
	    return exceptionClass;
	}

	/**
	 * This method returns the message associated with the exception class.
	 */
	public String getMessage() {
	    return message;
	}

	/**
	 * This method is called to check the post condition if an exception
	 * was expected and an exception was raised AND if the exception 
	 * raised is the same as the one expected while executing the method
	 * or constructor under test.
	 *
	 * @exception Fault is raised when a fatal assertion is encountered.
	 */
	protected void exceptionPostCondition() throws Fault {
	}
  
	/* ---- Private Members --*/
	private Class exceptionClass;
	private String message;
    }

    /**
     * This class contains a list of exceptions predicted by the test 
     * developer. If the test developer is testing a method or a constructor
     * that is capable of raising any exceptions, then he/she should create
     * an <CODE>ExceptionSet</CODE> object that contains a list of predicted
     * exceptions. 
     */

    public class ExceptionSet {
 

	/**
	 * This method adds an expected exception to the ExceptionSet
	 *
	 * @param ExpectedException An exception that was expected.
	 */
	public void addException(ExpectedException e) {
	    exceptionSet.addElement((Object) e);
	}

	/**
	 * This method returns the size of the ExceptionSet - in other
	 * words returns the number of exceptions that can be raised
	 * by this method.
	 */
	public int size() {
	    return exceptionSet.size();
	}

	/**
	 * This method returns a  exception from the exception set that
	 * is assignable to the parameter passed.
	 *
	 * @param t a throwable object
	 */
	public ExpectedException[] getExceptionList(Throwable t) {
	    Vector temp = new Vector();
	    ExpectedException ee = new ExpectedException(null, null);
	    Class eeClass;
	    for (int i = 0; i < exceptionSet.size(); ++i) {
		ee = getException(i);
		eeClass = ee.getExceptionClass();
		if ((eeClass.isAssignableFrom(t.getClass())) || 
		    (((RuntimeException.class).isAssignableFrom (t.getClass()))) ||
		    ((Error.class).isAssignableFrom (t.getClass()))) {
		    temp.addElement(ee);
		}
	    }
	    ExpectedException[] eeList = new ExpectedException[temp.size()];
	    temp.copyInto (eeList);
	    return eeList;
	}

	/**
	 * This method returns the exception at index i
	 * 
	 * @param i index of the element 
	 */
	public ExpectedException getException(int i) {
	    return (ExpectedException) exceptionSet.elementAt(i);
	}

	/**
	 * This method checks to see if the parameter passed is
	 * contained in this exception set or not.
	 *
	 * @param t A throwable object
	 */
	public boolean contains(Throwable t) {
	    ExpectedException ee;
	    Class eeClass;
	    for (int i = 0; i < exceptionSet.size(); ++i) {
		ee = getException(i);
		eeClass = ee.getExceptionClass();
		if ((eeClass.isAssignableFrom(t.getClass())) || 
		    ((RuntimeException.class).isAssignableFrom(t.getClass())) ||
		    ((Error.class).isAssignableFrom(t.getClass()))) {
		    return true;
		}
	    }
	    return false;
	}

	/* ---- Private Members --------*/
	private Vector exceptionSet = new Vector();
    }

    /**
     * This exception is raised whenever an error occurs in AssertionTest. 
     * An error may occur in the initialization process like init(), 
     * decodeArgs() etc where a test developer tries passing incorrect
     * parameter. Another place where this exception could be raised is
     * when the init() methods of Reporter/Generator are passed bad
     * arguments.
     *
     * <P>hardAssert() and softAssert() also raise this exception if there
     * is a fatal assertion or if the assertion check is done from 
     * say savePreState() or releasePreState() or any other method other
     * than the checkPostCondition() methods.
     */

    public static class Fault extends Exception {

	/**
	 * Construct a new Fault object with a message that corresponds
	 * to the assertion failure.
	 * 
	 * @param s the string containing a comment that corresponds to the Fault
	 */
	public Fault(String s) {
	    super(s);
	}

    }
}
