/*
 * Copyright (c) 2002, 2020 Oracle and/or its affiliates. All rights reserved.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0, which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the
 * Eclipse Public License v. 2.0 are satisfied: GNU General Public License,
 * version 2 with the GNU Classpath Exception, which is available at
 * https://www.gnu.org/software/classpath/license.html.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0
 *
 * */

package javasoft.sqe.javatest.lib;

import java.io.PrintWriter;
import javasoft.sqe.javatest.Status;
import javasoft.sqe.javatest.lib.MultiTest;

/* Imports for this test */
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.OutputStream;
import java.io.FileOutputStream;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.io.IOException;
import java.io.OptionalDataException;
import java.net.URL;
import java.lang.reflect.Method;

/**
 * Abstract base class for simple serialization tests.
 * This abstract base class extends the MultiTest library class with specific
 * features needed to perform a simple serialization test of serializable API 
 * classes.  This test assumes that the implementation of the toString()
 * and equals() methods will provide enough information to validate that correct
 * serialization and de-serialization have taken place.
 *
 * <P>You must supply the specific data to be serialized and de-serialized
 * to create a useful test class. There are three different test methods 
 * in this test class:
 * <DL>
 * <DT><B>setup</B>
 *    <DD>Setup for the persistent serialized data file.  This creates
 *        a data file in the test directory for the serialized form of the
 *        data supplied in the createValues() method.
 * <DT><B>readTest</B>
 *    <DD>Read test for the persistent serialized form.  This test reads
 *        the file generated by the <EM>setup</EM> test.
 * <DT><B>writeTest</B>
 *    <DD>This is a round trip test.  It writes data to an ObjectOutputStream
 *        and then reads that data back.
 *</DL>
 *
 * <P>The test description requires an <STRONG>executeArgs</STRONG> field.  The
 * executeArgs must have the following three parameters:
 * <DL>
 * <DT><B>-TestURL</B>
 *    <DD>The URL of the test description.  Please use the JavaTest Harness supplied
 *        value <EM>$testURL</EM>.
 * <DT><B>-TestCaseID</B>
 *    <DD>Which tests from the above list to be executed.  You will first need
 *        to execute <EM>setup</EM> to create the file used in the <EM>readTest</EM>.  
 *        Normally the value for TestCaseID will be <EM>ALL</EM> which runs
 *        both <EM>readTest</EM> and <EM>writeTest</EM>.
 * <DT><B>-FileName</B>
 *    <DD>The name of the file that is written during <EM>setup</EM> and read during
 *        <EM>readTest</EM>.  The value for fileName must fit the MS-DOS 8.3 file
 *        naming convention, and should end with the extension <EM>.ser</EM>.
 * </DL>
 *
 * <P>For an example of how to use this test class see 
 * tests/api/java_lang/Integer/manual.html#Serialized test.
 *
 * @author Kevin A. Smith
 * @version 1.11
 */
public abstract class SerializeTest extends MultiTest {

    /** URL for the persistent serialized data file. */
    protected URL serialFileURL;

    /** Array of values to be serialized */
    protected Object[] expectedValues;

    /** Flag to turn on/off the Object.equals() test in validation method.
     * This is for backwards compatibility only.
     * Please override the validation method whenever possible.
     */
    protected boolean doEqualsTest = true;

    /** Flag to turn on/off the Object.toString().equals() test in validation method.
     * This is for backwards compatibility only.
     * Please override the validation method whenever possible.
     */
    protected boolean doStringTest = true;

    /** Flag that indicates if the serialized data file needs to be generated.
     *  Test execution will not be performed if it is set to true. 
     */
    protected boolean setupSerFile = false;

    /** Default constructor */
    protected SerializeTest(){}

    /**
     * Initializes test using the execute arguments.
     * Calls the createValues method to create expected values.
     *
     * @exception SetupException raised when initialization 
     * is unsuccessful.
     *
     * @see createValues 
     *
     */
    protected void init() throws SetupException {

        /* Parse execute arguments */

        /* check if filename and testURL have
         * been defined
         */

        if( fileName == null ) {
            throw new SetupException( "No file name defined" );
        }
        if( testURL == null ) {
            throw new SetupException( "No Test URL defined" );
        }
        try {
            serialFileURL = new URL( testURL );
            serialFileURL = new URL( serialFileURL, fileName );
        } catch( IOException e ) {
            throw new SetupException( "Could not create test URL: " + e.toString() );
        }

        /* Create data values */

        Status tempStatus = createValues();
        if( tempStatus.getType( ) != Status.PASSED ) {
            throw new SetupException( tempStatus.getReason() );
        }

        // hack for the creation of .ser file 
        if (setupSerFile) {
            System.out.println("Serialized data file update returned " + 
                    "the following status: " + setup().getStatus());
            System.exit(0);
        }
               
    }


    /**  Decoding filename and testURL.
     *
     * This method tries to decode filename and testURL, 
     * supplied after "-FileName" and "-TestURL" accordingly, 
     * from argv starting with current index.
     *
     * There is an additional argument -setupSerFile that is used 
     * in order to generate the seralized data file, which is used during ReadTest
     * This argument should NOT be used for test execution and is for updating
     * the data file purpose only
     *
     * The serialization test requires three execute arguments:
     * <DL>
     * <DT><B>-TestURL</B>
     *    <DD>The URL of the test description.  Please use the JavaTest Harness supplied
     *        value <EM>$testURL</EM>.
     * <DT><B>-TestCaseID</B>
     *    <DD>Which tests from the above list to be executed.  You will first need
     *        to execute <EM>setup</EM> to create the file used in the 
     *        <EM>readTest</EM>.  Normally the value for TestCaseID will be 
     *        <EM>ALL</EM> which runs
     *        both <EM>readTest</EM> and <EM>writeTest</EM>.
     * <DT><B>-FileName</B>
     *    <DD>The name of the file that is written during <EM>setup</EM> and read during
     *        <EM>readTest</EM>.  The value for fileName must fit the MS-DOS 8.3 file
     *        naming convention, and should end with the extension <EM>.ser</EM>.
     * </DL>
     *
     * <P>The values for <EM>-TestCaseID</EM> are:
     * <DL>
     * <DT><B>readTest</B>
     *    <DD>Read test for the persistent serialized form.  This test reads
     *        the file generated by the <EM>setup</EM> test.
     * <DT><B>writeTest</B>
     *    <DD>This is a round trip test.  It writes data to an ObjectOutputStream
     *        and then reads that data back.
     * <DT><B>ALL</B>
     *    <DD>Executes the readTest and the writeTest.  It does not execute the
     *        test setup.
     * </DL>
     *
     * @param argv Execute arguments from the test harness or from the 
     *             command line
     * @param index current index into argv.
     *
     * @return number of arguments decoded if SerializeTest specific argument 
     *         is recognized, or 
     *         <CODE>super.decodeArg( argv, index )</CODE> otherwise. 
     *
     */
    protected int decodeArg( String argv[], int index ) throws SetupException {
        if( argv[index].equals( "-TestURL" ) ) {
            if ( index+1 < argv.length && ! argv[index+1].startsWith( "-" ) ) {
                testURL=argv[index+1];
                return 2;
            } else {
                testURL="";
                return 1;
            }
        } else if( argv[index].equals( "-FileName" ) ) {
            if ( index+1 < argv.length && ! argv[index+1].startsWith( "-" ) ) {
                fileName=argv[index+1];
                return 2;
            } else {
                fileName="";
                return 1;
            }
        } else if( argv[index].equals( "-setupSerFile" ) ) {
            setupSerFile = true;
            return 1;
        } else {
            return super.decodeArg( argv, index );
        }
    }

     /** Define set of "ALL" test cases
     *
     * Overridden version of MultiTest.getAllTestCases().  This defines
     * the set of methods to be executed when the TestCaseID value is
     * ALL.  The list of all tests to be executed is manually defined.
     *
     */
    protected void getAllTestCases( ) throws SetupException {
        Method tests[] = {
            getTestCase( "testRead" ),
            getTestCase( "testWrite" ),
        };
        testMethods = tests;
    }



    /**
     * Abstract method to define the expectedValues array.
     * This method is called by the init() method to assign values
     * to the expectedValues array.
     *
     * @return Status.passed("") if expectedValues array was initialized
     *         successfully, or Status.failed( ) with an informative 
     *         message if unsuccessful.
     *
     */
    protected abstract Status createValues( );


    /** Creates serialized data file to be read during ReadTest.
     *
     * @return WrapStatus with wrapped status of Status.passed("OKAY") if the data 
     *         file was written successfully, or Status.failed( ) with an informative 
     *         message if unsuccessful.
     *
     */
    public WrapStatus setup() {
        Status s = null;
        try {
            FOSFactory fosfact = (FOSFactory)Class.forName("javasoft.sqe.javatest.lib.FOSFactoryImpl").
                                      newInstance();
            OutputStream oStream = fosfact.getFileOutputStream(serialFileURL.getFile());
            ObjectOutputStream objOStream = new ObjectOutputStream( oStream );
            s = write( objOStream, expectedValues );
            oStream.close();
        } catch (ExceptionInInitializerError e) {
            e.printStackTrace(log);
            s = Status.failed("Unexpected error : "+e);
        } catch (LinkageError e) {
            e.printStackTrace(log);
            s = Status.failed("Unexpected error : "+e);
        } catch (ClassNotFoundException e) {
            e.printStackTrace(log);
            s = Status.failed("Unexpected error : "+e);
        } catch (InstantiationException e) {
            e.printStackTrace(log);
            s = Status.failed("Unexpected error : "+e);
        } catch (IllegalAccessException e) {
            e.printStackTrace(log);
            s = Status.failed("Unexpected error : "+e);
        } catch (IOException e) {
            s = Status.failed("Unexpected: " + e);
        }
        return new WrapStatus(s);
    }

    /** Read Serialized data test
     *
     * @return Status.passed("OKAY") if the data file was written
     *         successfully, or Status.failed( ) with an informative 
     *         message if unsuccessful.
     * @exception IOException Rethrows IOException from IO calls.
     * @exception ClassNotFoundException Thrown if the test is unable to 
     *                                un-marshal the data from the 
     *                                serialized stream.
     * @exception OptionalDataException Rethrown from calls to readObject that have 
     *                               optional data.
     *                               
     */
    public Status testRead() throws ClassNotFoundException, IOException, 
        OptionalDataException 
        {
            ObjectInputStream iStream = new ObjectInputStream( serialFileURL.openStream() );
            Status s = read( iStream, expectedValues );
            iStream.close();
            return s;
        }

    /** Write and then read serialized data test
     *
     * @return Status.passed("OKAY") if the data file was written
     *         successfully, or Status.failed( ) with an informative 
     *         message if unsuccessful.
     * @exception IOException Rethrows IOException from IO calls.
     * @exception ClassNotFoundException Thrown if the test is unable to 
     *                                un-marshal the data from the 
     *                                serialized stream.
     * @exception OptionalDataException Rethrown from calls to readObject that have 
     *                               optional data.
     *
     */
    public Status testWrite() throws ClassNotFoundException, IOException, 
            OptionalDataException 
        {
            ObjectOutputStream oStream;
            ObjectInputStream iStream;

            /* Create a byte array to hold the serialized values
             * serialize them, and store in a byte array.
             */
            ByteArrayOutputStream baos = new ByteArrayOutputStream();
            oStream = new ObjectOutputStream( baos );
            write( oStream, expectedValues );
            byte bytes[] = baos.toByteArray();
            baos.close();
                
            /* create a byte array input stream, and deserialize
             * the dates.
             */
            ByteArrayInputStream bais = new ByteArrayInputStream( bytes );
            iStream = new ObjectInputStream( bais );
            Status s = read( iStream, expectedValues );
            iStream.close();
            return s;
        }


    /** Method to validate correct serialization/de-serialization of each object.
     * 
     * This method is called any time SerializeTest needs to validate that an 
     * object has been correctly serialized and de-serialized.  It compares the
     * object before serialization with the object after serialization and 
     * de-serialization.  If the two objects are equal, then the object was
     * correctly serialized and de-serialized.
     *
     * <P>The default implementation is to compare the results of Object.equals() and
     * Object.toString().equals().  If both of these checks return true, then the
     * object was correctly serialized and de-serialized.  Some classes should use
     * some other check of equality.  For example, class Throwable does not override
     * Object.equals(), so you cannot use Throwable.equals() to compare two different
     * objects.  Therefore, this method is overridden in the serialized form test of 
     * of class Throwable.
     *
     * @param expectedResult The object before serialization.
     * @param result The object after serialization and de-serialization
     * @param stringResult The serialized string value of the object
     *
     * @return Status.passed( "" ) if the de-serialized object is the same as the
     *         object before serialization.  Otherwise it will return Status.failed()
     *         with an informative message describing why the two objects are not
     *         equal.
     */
    protected Status validate( Object expectedResult, Object result, String stringResult ) {

        String expectedString = expectedResult.toString();

        if( doEqualsTest && ( ! expectedResult.equals( result ) ) ) {
            return Status.failed( "Equals test, expected: " + 
                                  expectedString +
                                  ", received: " +
                                  result.toString() );
        }
        if( doStringTest && ( ! expectedString.equals( stringResult ) ) ) {
            return Status.failed( "String equals test, expected: " +
                                  expectedString +
                                  ", received: " +
                                  stringResult );
        }

        return Status.passed( "" );
    }


    /*********************************** Private Methods ***********************************/
    /** Actual test for reading objects from a stream */
    private Status read( ObjectInputStream iStream, Object[] expectedResult ) 
        throws ClassNotFoundException, IOException, OptionalDataException {
            Object testVal;
            String testValString;
            Status validateStatus;

            int serializedObjects = iStream.readInt();
            if( serializedObjects != expectedResult.length ) {
                return Status.failed( "Expected: " + expectedResult.length +
                                      " serialized objects.  Result: " +
                                      serializedObjects );
            }
            for( int i = 0; i < serializedObjects; ++i ) {
                testVal = iStream.readObject();
                testValString = (String) iStream.readObject();

                validateStatus = validate( expectedResult[i], testVal, testValString );

                if( validateStatus.getType() != Status.PASSED ) {
                    return validateStatus;
                }
            }

            // if we've gotten here, then everything worked okay.
            return Status.passed( "OKAY" );
    }

    /** Actual test for writing objects to a stream */
    private Status write( ObjectOutputStream oStream, Object[] desiredVal ) 
        throws IOException 
        {
            int i;

            oStream.writeInt( desiredVal.length );
            for( i = 0; i < desiredVal.length; ++i ) {
                oStream.writeObject( desiredVal[i] );
                oStream.writeObject( desiredVal[i].toString() );
            }
            oStream.flush();
            return Status.passed( "OKAY" );
        }

    private String testURL = null;
    private String fileName = null;
}

interface FOSFactory {
    public OutputStream getFileOutputStream(String file) throws IOException;
}

class FOSFactoryImpl implements FOSFactory {
    public OutputStream getFileOutputStream(String file) throws IOException {
        return new FileOutputStream(file);
    }
}

/**
 * class to wrap the Status object to prevent the setup() method from
 * being interpreted as a test case
 */
class WrapStatus {
    private Status s = null;
    WrapStatus(Status s) {
        this.s = s;
    }

    Status getStatus() {
        return s;
    }
}
