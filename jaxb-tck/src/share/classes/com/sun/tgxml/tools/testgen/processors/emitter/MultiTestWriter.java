/*
 * Copyright (c) 2001, 2020 Oracle and/or its affiliates. All rights reserved.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0, which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the
 * Eclipse Public License v. 2.0 are satisfied: GNU General Public License,
 * version 2 with the GNU Classpath Exception, which is available at
 * https://www.gnu.org/software/classpath/license.html.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0
 */

package com.sun.tgxml.tools.testgen.processors.emitter;

import com.sun.jmpp.lib.JmppLibAPI;
import com.sun.jmpp.lib.LibAPIException;
import com.sun.jmpp.lib.LibAPIProperties;
import com.sun.jmpp.lib.InvalidPropertyException;
import com.sun.tgxml.tools.indexgen.api.TestSuite;
import com.sun.tgxml.tools.indexgen.api.impl.TestSuiteImpl;
import com.sun.tgxml.tjtf.IRObj;
import com.sun.tgxml.tjtf.api.tests.TestGroup;
import com.sun.tgxml.tjtf.api.exceptions.TestFileException;
import com.sun.tgxml.tjtf.api.code.*;
import java.util.*;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import com.sun.tgxml.tjtf.api.documentation.*;
import com.sun.tgxml.tjtf.api.tests.*;
import com.sun.tgxml.tjtf.api.attributes.*;
import com.sun.tgxml.tjtf.api.data.*;
import com.sun.tgxml.tjtf.tools.Shell;
import com.sun.tgxml.tjtf.tools.BuildProperties;
import com.sun.tgxml.tools.elgen.ExcludeListCollector;
import com.sun.tgxml.tools.elgen.IncorrectAttributesException;
import com.sun.tgxml.tools.elgen.ExcludeListUtils;
import com.sun.tgxml.tjtf.resources.LibResHandler;
import com.sun.tgxml.tools.testgen.LibUtils;
import com.sun.tgxml.tools.testgen.api.source.java.Comment;
import com.sun.tgxml.tools.testgen.api.TestDescriptionIR;
import com.sun.tgxml.tjtf.tools.options.Option;
import com.sun.tgxml.tjtf.tools.options.ParseArgumentException;
import com.sun.tgxml.util.IR;
import com.sun.tgxml.util.CopyrightManager;
import com.sun.tgxml.util.MiscUtils;


/**
 * This class is responsible for MultiTest based test generation.
 */
public class MultiTestWriter
    extends JmppLibAPI
    implements Generator, CopyrightManager.Constants, 
    	EmitterManager.HtmlConflictModeInsert
{
    protected IRContainer container;

    protected Shell m_shell;

    protected ExcludeListCollector m_elCollector;
    protected Properties m_properties;
    protected String relativeTDName;
    //hardcoded copyright
    protected String copyright = null;

    // the value of "serialTestType" AttrElem
    // (for serial tests generated by serTempl)
    protected String serialTestType = null;

    /**
     * the real name of class uner test
     */
    protected String classUnderTest = null;

    /**
     * the name of package uner test
     */
    protected String packageUnderTest = null;

    /**
     * TestGroup MemberSig value
     */
    protected String tgMemberSig = null;

    /**
     * contains list of list of inline libraries IDs for the currectly
     * processing TestGroup.
     * Used to quick check wether library is inline or not
     */
    protected ArrayList inlineLibrariesIDs = new ArrayList();

    /**
     * collector for tck specific TestDescription field entries
     */
    protected TDEntriesCollector tdCollector = createTDEntriesCollector();
    
    /**
    * set of conflict fiels
    */
    protected HashSet conflictFiles = new HashSet();

    public MultiTestWriter() {
    }

    public void setExcludeListCollector(ExcludeListCollector collector) {
        m_elCollector = collector;
    }

    public void setProperties(Properties props) {
        m_properties = props;
    }

    public Shell getShell() throws TestFileException {
        return m_shell;
    }

    public void setShell(Shell shell) {
        m_shell = shell;
    }

    /**
     * Emits JavaTest source files and HTML descriptions into
     * the output dir.
     * <p>
     * This generator uses a value of "tdFile" AttrElem specified
     * in the TestGroup as a name of HTML description file.
     * If not specified default value is used.
     * <p>
     * Passed TestSuites(parsed .tdoc.files) are processed as shown below:
     * <ul>
     * <li>
     *     if TestSuite with 'xxx' id is passed then to create 'xxx.html'
     *     index file  title and description will be taken from
     *     'xxx' TestSuite
     * </li>
     * <li>
     *     if TestSuite with 'xxx' id is not passed then to create 'xxx.html'
     *     index file default values for title and description will be used
     * </li>
     * <li>
     *     if TestSuite with 'xxx' id is passed but 'xxx.html' index file
     *     is not generated (no passed TestGroup has "tdFile" set to 'xxx')
     *     'xxx' TestSuite will be silently ingnored
     * </li>
     * </ul>
     * <p>Note:
     * This implementation of IREmitter ignores files parameter.
     */
    public void generate(IRObj[] trees) throws TestFileException {
        Enumeration treeGroups = splitByTDFile(trees);
        while (treeGroups.hasMoreElements()) {
            IRObj[] treeGr = (IRObj[])treeGroups.nextElement();
            container = new IRContainer();
            container.init(treeGr);
            MultiTestWriter clone;
            try {
                clone = (MultiTestWriter) getClass().newInstance();
            } catch (IllegalAccessException iae) {
                throw new TestFileException(
                    "Can not instantiate copy of MultiTestWriter: " + iae);
            } catch (InstantiationException ie) {
                throw new TestFileException(
                    "Can not instantiate copy of MultiTestWriter: " + ie);
            } catch (ExceptionInInitializerError eiie) {
                throw new TestFileException(
                    "Can not instantiate copy of MultiTestWriter: " + eiie);
            }
            clone.setExcludeListCollector(m_elCollector);
            clone.setProperties(m_properties);
			clone.setConflictFiles(conflictFiles);
			clone.setOriginal(this);
            clone.makeOut(container);
        }
    }

    public void makeTest(IRContainer container) throws TestFileException {
        //Process TestSuite objects
        ////
        processTestSuite(container.getTestSuite(), container.getTestedClass(),
                container.getTestedPackage());

        while (container.hasMoreTestGroups()) {
            TestGroup tg = container.getTestGroup();
            processTestGroup(tg, container.getOutputDir());
            processInlineClassAndData(tg, container);

        }
    }

    public void makeOut(IRContainer container) throws TestFileException {
        setOutputDir(container.getOutputDir());
        if (m_properties != null) {
            String link = m_properties.getProperty(
                    EmitterManager.TESTGEN_COPYRIGHT_LINK_PROP);
            if (link != null) {
                if (link.startsWith(".." + File.separator)) {
                    // jmpp adds '../' to copyright file name
                    link = link.substring(2 + File.separator.length());
                }
                System.setProperty(EmitterManager.JMPP_COPYRIGHT_LINK_PROP,
                        link);
            }

        }
        loadDefaults();
        outBuffer = new StringBuffer();
        makeTest(container);
        testclose();
        outBuffer = null;
    }

    protected void setOutput(String fileName,
            String extension, String dirName) {
        super.setOutput(fileName);
        this.currentFileName = fileName+"."+extension;
    }

    public void generate(IRObj tree)
            throws TestFileException {
        IRObj[] trees = {tree};
        generate(trees);
    }


    /**
     * splits array of IRObj by "tdFile" AttrElem
     * Returns enumeration of IRObj[]
     */
    protected Enumeration splitByTDFile(IRObj[] trees) throws TestFileException {
        // hash: "tdFile" <--> list of TestGroups
        Hashtable hash = new Hashtable();
        HashMap testSuites = new HashMap();
        for (int i = 0; i < trees.length; i++) {
            if (trees[i] instanceof TestSuite) {
                 TestSuite ts = (TestSuite)trees[i];
                 testSuites.put(ts.getID(), ts);
            } else if (trees[i] instanceof TestGroup) {
                 String tdFile = LibUtils.getTDFile((TestGroup)trees[i]);
                 if (tdFile == null)
                     tdFile = "index";
                 if (hash.containsKey(tdFile)) {
                     Vector v = (Vector)hash.get(tdFile);
                     v.add(trees[i]);
                 } else {
                     Vector v = new Vector();
                     v.add(trees[i]);
                     hash.put(tdFile, v);
                 }
            } else {
                throw new TestFileException(LibResHandler.getResStr(
                        "testgen.error.unknownIR", trees[i].toString()));
            }
        }

        Vector result = new Vector(hash.size());
        Enumeration keys  = hash.keys();
        while (keys.hasMoreElements()) {
            String tdFile = (String)keys.nextElement();
            Vector v = (Vector)hash.get(tdFile);
            TestSuite ts = (TestSuite)testSuites.get(tdFile);
            if (ts != null) {
                 v.add(ts);
            }
            result.add( v.toArray(new IRObj[0]) );
        }

        return result.elements();
    }

    protected ArrayList importList;

    protected StringBuffer externalRC;
    protected StringBuffer inlineRC;
    protected String originalSourceName;

    protected String getTestDescriptionName() {
        return (relativeTDName == null) ? inName : relativeTDName;
    }

    protected String getCopyrights() {
        if (copyright == null)
            return super.getCopyrights();
        else {
            return copyright;
        }
    }   

    protected void processTestGroup(TestGroup testGroup, String outputDirName)
            throws TestFileException {
	copyright = IR.getAttrElem("copyright", testGroup);    
        String fileName = outputDirName;
        fileName = fileName.trim().endsWith(File.separator)?fileName.trim():
                fileName.trim() + File.separator;

        String sourceName = IR.getAttrElem(IR.SourcePathAttrElemName, testGroup);
        if (sourceName == null || sourceName.trim().equals("")) {
            throw new TestFileException(LibResHandler.getResStr("testgen.error.no_sourcepath", testGroup.getID()));
        }
        File f = new File(sourceName);
        inName = f.getName();
        inDir = f.getParent();

        relativeTDName = IR.getAttrElem(IR.relSourcePathAttrElemName,
                testGroup);
        serialTestType = IR.getAttrElem(IR.serialTestTypeAttrElemName,
                testGroup);

        try {
            classUnderTest =
                    testGroup.getTGDocumentation().getTestedClass().trim();
        } catch (NullPointerException e) {
            classUnderTest = null; // no concrete class under test
        }

        try {
            packageUnderTest =
                    testGroup.getTGDocumentation().getTestedPackage().trim();
        } catch (NullPointerException e) {
            packageUnderTest = null; // no concrete package under test
                                     // (should never arise)
        }



        // source code info
        scInfo = IR.getAttrElem("scInfo", testGroup);

        importList = new ArrayList();
        externalRC = new StringBuffer();
        inlineRC = new StringBuffer();
        originalSourceName = IR.getAttrElem("OriginalSourceName", testGroup);

        this.file = testGroup.getID();
        inlineLibrariesIDs = IR.getInlineLibrariesIDs(testGroup);
        processTGDocumentation(testGroup.getTGDocumentation());
        processTGAttributes(testGroup.getTGAttributes());
        CodeSet codeSet = testGroup.getCodeSet();
        if (codeSet != null) {
            this.baseClass = codeSet.getBaseClass();
            processCodeSet(codeSet);
        }
        processInlineLibraries(testGroup.getLibraries());
        tdCollector.processTestItem(testGroup);
        this.context = getTestGroupContext(testGroup);
        this.executeArgs = getTestGroupExecuteArgs(testGroup);

        fileName += htmlindex + ".html#" + testGroup.getID();

        ArrayList testCases = testGroup.getTestCases();
        if (testCases != null) {
            for(Iterator it = testCases.iterator(); it.hasNext();) {
                TestCase _tc = (TestCase)it.next();
                processTestCase(_tc);
                fireGenerationEvent(_tc, fileName);
            }
        }

        // process imports, remove duplicates if any
        ArrayList imports = detectImports(importList);

        this.imports = "\n" + getImportString(imports);
        // process rcfiles
        if (externalRC.length() > 0) {
            rcfiles = externalRC.toString();
        }
        // process inline rcfiles
        if (inlineRC.length() > 0) {
            rcfilesInline = inlineRC.toString();
        }

        this.javaclose();
        fireGenerationEvent(testGroup, fileName);
    }

    protected void processTestCase(TestCase testCase) throws TestFileException {
        this.testCaseID = testCase.getID();
        processTCAttributes(testCase.getTCAttributes());
        processCodeSet(testCase.getCodeSet());
        processTCDocumentation(testCase.getTCDocumentation(), testCase.getID());
        TestCode code = testCase.getTestCode();
        if (code == null) {
            throw new TestFileException(
                        LibResHandler.getResStr("testgen.error.testcase.codenotfound", testCase.getID()));
        } else if (code.getSourceLang() != null
                && !code.getSourceLang().trim().equals("")
                && !code.getSourceLang().equals(Code.ctStr_langType_java)) {
            throw new TestFileException(LibResHandler.getResStr(
                    "testgen.error.testcase.langnotsupported", code.getSourceLang()));
        }

        String varID = testCase.getVarID();
        if (varID == null || varID.length() == 0) {
            varID = "";
        } else {
            varID = " // VariantID = " + varID;
        }

        this.code = "{" + varID + "\n" + code.getSource() + "}\n";
        this.gen();
    }

    protected void processTCAttributes(TestCaseAttributes tcAttributes)
           throws TestFileException {
        if (tcAttributes == null)
            return;
        processTimeOut(tcAttributes);
    }


    protected void processTCDocumentation(TestCaseDocumentation tcDocumentation,
            String testCaseID) throws TestFileException {
        this.author = appendString(this.author, ", ", "", tcDocumentation.getAuthors());
        if (tcDocumentation.getTestCaseSpecs() == null) {
            throw new TestFileException(LibResHandler.getResStr("testgen.error.testcase.nodoc", testCaseID));
        } else {
            Iterator it = tcDocumentation.getTestCaseSpecs().iterator();
            while(it.hasNext()) {
                processTestCaseSpec((TestCaseSpec)it.next());
                if (it.hasNext()) this.store();
            }
        }
    }

    protected void processTestCaseSpec(TestCaseSpec testCaseSpec)
                throws TestFileException {
        ArrayList expectedValues = new ArrayList();
        int testTechnique = getTestTechnique(testCaseSpec.getTestTechnique());
        this.testTechnique = testTechnique;
        String memberSig = testCaseSpec.getMemberSig();
        if (memberSig == null && serialTestType != null) {
            memberSig = SERTEST_MEMBERSIG_PREFIX;
            if (serialTestType.equals("ConstructorTests")) {
                 memberSig += "deserialization of " +  classUnderTest;
            } else if (serialTestType.equals("InputTests")) {
                 memberSig += "serialization of " +  classUnderTest;
            } else {
                 memberSig += serialTestType;
            }
        } else if (memberSig == null && tgMemberSig == null) {
            if (classUnderTest != null) {
                memberSig = FUNCTIONAL_MEMBERSIG_PREFIX + classUnderTest;
            } else {
                memberSig = FUNCTIONAL_MEMBERSIG_PREFIX + packageUnderTest;
            }
        }

        if (memberSig == null) {
            memberSig = tgMemberSig;
        }

        this.method  = setStringValue(this.method, memberSig);
        this.precondition =
            appendString(this.precondition, "\n", "", testCaseSpec.getPreconditions());

        if (testCaseSpec.getExpectedResultExceptions() != null) {
            Iterator it = testCaseSpec.getExpectedResultExceptions().iterator();
            while(it.hasNext()) {
                ExpectedResultException ex = (ExpectedResultException)it.next();
                expectedValues.add(ex.getException());
            }
        }

        if (testCaseSpec.getExpectedResultSideEffects() != null) {
            Iterator it = testCaseSpec.getExpectedResultSideEffects().iterator();
            while(it.hasNext()) {
                ExpectedResultSideEffect se = (ExpectedResultSideEffect)it.next();
                expectedValues.add(se.getSideEffect());
            }
        }

        this.expected = appendString(this.expected, "\n", "", expectedValues);

        ArrayList values = new ArrayList();

        if (testTechnique == JmppLibAPI.ASSERTION_TESTING) {
            if (testCaseSpec.getAssertions() != null) {
                Iterator it = testCaseSpec.getAssertions().iterator();
                while(it.hasNext()) {
                    Assertion as = (Assertion)it.next();
                    if (as instanceof InlineAssertion) {
                        values.add(((InlineAssertion)as).getValue());
                    }
                }
            }
        } else {
            if (testCaseSpec.getInputs() != null) {
                Iterator it = testCaseSpec.getInputs().iterator();
                while(it.hasNext()) {
                    Input input = (Input)it.next();
                    values.add(input.getName() + ": " + input.getValue());
                }

            }
        }

        ExpectedResultValue tcExpectedResultValue =
                testCaseSpec.getExpectedResultValue();
        boolean legacymode = "true".equals(BuildProperties.getString(
                "legacymode.testgen.ExpectedResultValue"));
        if (tcExpectedResultValue != null) {
            if (testTechnique == JmppLibAPI.ASSERTION_TESTING && values.size() > 0 && !legacymode) {
                this.expectedResultValue = tcExpectedResultValue.getValue();
            } else {
                values.add("output: " + tcExpectedResultValue.getValue());
            }
        }


        this.values = appendString(this.values, "\n", "", values);
    }




    protected void processTGDocumentation(
            TestGroupDocumentation tgDocumentation) throws TestFileException{

        this.filetitle = tgDocumentation.getTitle();
        this.filePurpose = tgDocumentation.getDescription();
        this.author = appendString(this.author, ", ", "", tgDocumentation.getAuthors());
        tgMemberSig = tgDocumentation.getMemberSig();
    }

    protected void processTGAttributes(TestGroupAttributes tgAttributes)
            throws TestFileException {

        Iterator keywordsIt = tgAttributes.getKeywords().iterator();

		while(keywordsIt.hasNext()) {
			String keyword =  keywordsIt.next().toString();
			if (getDefaultKeywords().indexOf(keyword) == -1) {
				if (this.keywords == null) {
					this.keywords =  keyword;
				} else {
					this.keywords +=  " " + keyword;
				}
			}
        }

        this.rmicClass = tgAttributes.getRMICClasses();
        // this.context = tgAttributes.getContext();
        // this.executeArgs = tgAttributes.getExecuteArgs();
        Iterator selectIt = tgAttributes.getSelectIfs().iterator();
        if(selectIt.hasNext() && this.selectIf == null) {
            this.selectIf = selectIt.next().toString();
        }
        while(selectIt.hasNext())
                this.selectIf += " " + selectIt.next().toString();

        Iterator remotesIt = tgAttributes.getRemotes().iterator();
        while(remotesIt.hasNext()) {
            if (this.remote != null) {
                this.remote += "\n" + remotesIt.next();
            } else {
                this.remote = (String)remotesIt.next();
            }
        }

        String tdFile = LibUtils.getTDFile(tgAttributes);
        if (tdFile != null && !tdFile.trim().equals("")) {
            this.htmlindex = tdFile.trim();
        } else {
            this.htmlindex = "index";
        }

        processTimeOut(tgAttributes);
    }

    protected void processTimeOut(TestAttributes attrs)
            throws TestFileException {
        String tOut = attrs.getTimeout();
        if (tOut != null && tOut.trim().length() > 0) {
            try {
                int t = Integer.parseInt(tOut);
                this.timeout = Math.max(this.timeout, t);
            } catch (NumberFormatException e) {
                throw new TestFileException("Illegal Timeout value: " + tOut);
            }
        }
    }

    protected void processCodeSet(CodeSet codeSet) throws TestFileException {

        if (codeSet != null) {
            ArrayList codeSetImports = codeSet.getImports();
            if (codeSetImports != null && !codeSetImports.isEmpty()) {
                importList.addAll(codeSetImports);
            }
            processDependencies(codeSet.getDependencies());
            processSupportCode(codeSet.getSupportCode());
            processSupportClasses(codeSet.getSupportClasses());
            processData(codeSet.getData());
        }

    }

    protected void processDependencies(ArrayList dependencies) throws TestFileException {
/* Dependencies are processed by LibLinker
        String packageName = getTestPackageName(testpackage, testclass);
        if (dependencies != null && dependencies.size() >0) {
            for (Iterator libs = dependencies.iterator(); libs.hasNext();) {
                Object lib = libs.next();
                if (lib instanceof LibraryDependency) {
                    String id = ((LibraryDependency)lib).getID().trim();
                    if (!isInlineLibrary(id)) {
                        ArrayList libImports = LibUtils.getLibraryImports(id);
                        if (libImports != null && !libImports.isEmpty()) {
                            Iterator it = libImports.iterator();
                            while (it.hasNext()) {
                                String imp = it.next().toString();
                                // import class is in the same package as test group
                                if (imp.substring(0, imp.lastIndexOf('.')).equals(packageName)) {
                                    continue;
                                }
                                // !!!!
                                // This is a temporary solution for
                                // serial tests : dependency imports are not added.
                                if (!imp.startsWith("javasoft.sqe.serial")) {
                                    importList.add(imp);
                                }
                            }
                        }
                    }
                }
            }
        }
*/
    }

    /**
     * Removes redundant imports from the passed list
     */
    protected ArrayList detectImports(ArrayList importList) {
        String packageName = getTestPackageName(testpackage, testclass);
        ArrayList result = new ArrayList();
        for(Iterator it = importList.iterator(); it.hasNext();) {
            String imp = (String)it.next();
            if (imp != null && !imp.equals("")  && !result.contains(imp)
               && (imp.lastIndexOf('.') < 0 ||
                  !imp.substring(0, imp.lastIndexOf('.')).equals(packageName))) 
            {
                 result.add(imp);
            }
        }
        return result;
    }

    protected void processSupportCode(SupportCode supportCode) {
        if (supportCode != null
                && (supportCode.getSourceLang() == null
                || supportCode.getSourceLang().equals("")
                || supportCode.getSourceLang().equals(Code.ctStr_langType_java))) {
            if(this.codeinclude ==null) {
                this.codeinclude = "";
            }
            this.codeinclude += "\n" + formatLibCode(supportCode.getSource());
        }
    }

    protected String formatLibCode(String code) {
        StringBuffer buf = new StringBuffer(code);
        int i = 0;
        // remove the starting empty lines
        while (buf.length()> i) {
            if (buf.charAt(i) > ' ') {
                break;
            }
            if (buf.charAt(i) == '\n') {
                buf = buf.delete(0, i + 1);
                i = 0;
            } else {
                // white space but no character return
                i++;
            }
        }
        // remove trailing white spaces
        while (buf.length() >= 1 && buf.charAt(buf.length() - 1) <= ' ') {
            buf = buf.deleteCharAt(buf.length() - 1);
        }
        if (buf.length() != 0) {
            buf.append('\n');
        }
        return buf.toString();
    }

    protected void processSupportClasses(ArrayList supportClasses)
           throws TestFileException {
        ArrayList uses = new ArrayList();
        if (supportClasses != null) {
            Iterator it = supportClasses.iterator();
            while(it.hasNext()) {
                SupportClass s_class = (SupportClass)it.next();
                if (s_class instanceof ExternalSupportClass) {
                    uses.add(((ExternalSupportClass)s_class).getSourceName());
                } else if (s_class instanceof InlineSupportClass) {
                    InlineSupportClass is_class = (InlineSupportClass)s_class;
                    if (is_class.getSourceLang() == null
                            || is_class.getSourceLang().equals(Code.ctStr_langType_java)) {
                        if (is_class.isExport()) {
                            uses.add(is_class.getTargetName());
                        } else {
                            if(this.classinclude ==null) {
                                this.classinclude = "";
                            }
                            this.classinclude += "\n" + formatLibCode(is_class.getSource());
                        }
                    }
                }
            }
        }

        this.uses = appendString(this.uses, " ", "", uses);
    }


    protected void processInlineClassAndData(TestGroup tg,
            IRContainer container) throws TestFileException {

        InlineSupportUtil.generateInlines(
            tg,
            container.getOutputDir(),
            scInfo,
            getProperties().getCopyrightNotice(),
            getTestPackageName(
                container.getTestedPackage(), container.getTestedClass()),
            null //no imports by default
        );

    }


    protected void processInlineLibraries(ArrayList libs)
            throws TestFileException {
        if (libs != null) {
            Iterator it = libs.iterator();
            while(it.hasNext()) {
                processInlineLibrary((InlineLibrary)it.next());
            }
        }
    }

    protected void processInlineLibrary(Library lib) throws TestFileException {
        if (lib instanceof InlineLibrary) {
            processInlineLibrary((InlineLibrary)lib);
        } else {
            throw new TestFileException("Library: " + lib + " is not inline");
        }
    }

    protected void processInlineLibrary(InlineLibrary lib) throws TestFileException {
        CodeSet codeSet = lib.getCodeSet();
        if (codeSet != null) {
            processDependencies(codeSet.getDependencies());
            processData(codeSet.getData());

            ArrayList codeSetImports = codeSet.getImports();
            if (codeSetImports != null && !codeSetImports.isEmpty()) {
                importList.addAll(codeSetImports);
            }

            SupportCode supCode = codeSet.getSupportCode();
            ArrayList supClasses = codeSet.getSupportClasses();
            if (supCode == null && (supClasses == null || supClasses.isEmpty())) {
                return;
            }

            LibDocumentation libDoc = lib.getLibDocumentation();
            String libCodeCommentString = "";
            String libClassesCommentString = "";
            if (libDoc != null) {
                Comment libComment = new Comment();
                if (libDoc.getTitle() != null)
                    libComment.setContent(libDoc.getTitle());
                if (libDoc.getDescription() != null)
                    libComment.addContent(libDoc.getDescription());
                if (libDoc.getAuthors() != null)
                    libComment.addContent("Author: " + libDoc.getAuthors());
                libComment.setType(Comment.PLAIN);
                libClassesCommentString = libComment.toString();
                libComment.setIndent(4);
                libCodeCommentString = libComment.toString();
            }

            String libIDString = "Library: " + lib.getID();
            String libVarID = lib.getVarID();
            if (libVarID != null && libVarID.length() > 0) {
                libIDString += ";  Variant: " + libVarID;
            }

            if (supCode != null) {
                if(this.codeinclude == null) {
                    this.codeinclude = "";
                }
                while(codeinclude.endsWith("\n\n")) {
                    codeinclude =
                        codeinclude.substring(0, codeinclude.length() - 1);
                }
                this.codeinclude += "\n    // >>>> " + libIDString + "\n\n";
                this.codeinclude += libCodeCommentString;
                while(codeinclude.endsWith("\n\n")) {
                    codeinclude =
                        codeinclude.substring(0, codeinclude.length() - 1);
                }
                processSupportCode(supCode);
                this.codeinclude += "\n    // <<<<<<<< " + libIDString + " <<<<<<<<\n\n";
            }

            if (supClasses != null) {
                if(this.classinclude == null) {
                    this.classinclude = "";
                }
                while(classinclude.endsWith("\n\n")) {
                    classinclude =
                        classinclude.substring(0, classinclude.length() - 1);
                }
                this.classinclude += "\n// >>>> " + libIDString + "\n\n";
                this.classinclude += libClassesCommentString;
                while(classinclude.endsWith("\n\n")) {
                    classinclude =
                        classinclude.substring(0, classinclude.length() - 1);
                }
                processSupportClasses(supClasses);
                this.classinclude += "\n// <<<<<<<< " + libIDString + " <<<<<<<<\n\n";
            }
        }
    }

    protected boolean isInlineLibrary(String libID) {
        return libID != null && inlineLibrariesIDs.contains(libID);
    }

    protected void processData(ArrayList dataArray) throws TestFileException {
        if (dataArray != null) {
            Iterator it = dataArray.iterator();

            while (it.hasNext()) {
                Data data  = (Data)it.next();
                if (data.getType().isResource()) {
                    String sname = null;
                    StringBuffer rc = null;
                    if (data instanceof ExternalData) {
                        sname = ((ExternalData)data).getSourceName();
                        rc = externalRC;
                        if (sname.endsWith(".rc")) {
                            sname = sname.substring(0,sname.lastIndexOf(".rc"));
                        } 
                    } else {
                        sname = ((InlineData)data).getTargetName();
                        rc = inlineRC;

                    }
                    if (rc.length() > 0) {
                        rc.append(" ");
                    }
                    rc.append(sname);
                }
            }
        }
    }

    protected void processTestSuite(TestSuite testSuite,
            String testedClass, String testedPackage) {
        this.index = testSuite.getDescription();
        this.testpackage = testedPackage;
        this.testclass = testedClass;
        try {
            String title = testSuite.getTitle();
            if (title != null && !title.equals("")) {
                this.indextitle = title;
            }
        } catch (TestFileException e) {
            // Have no idea why an exception could be thrown here.
        }
        this.testcreate();
    }

    protected void installRCFile(File src, File dst) throws LibAPIException {
        if (!MiscUtils.isTextFile(src)) {
            super.installRCFile(src, dst);
            return;
        }
        Exception e = null;

        try {
            CopyrightManager.updateCopyright(src, dst);
        } catch (FileNotFoundException fe) {
            e = fe;
        } catch (SecurityException se){
            e = se;
        } catch (IOException ioe) {
            e = ioe;
        }
        if (e != null) {
            e.printStackTrace();
            String msg = "error copying resource file " + src.getAbsolutePath();
            throw new LibAPIException(msg + ": " + e);
        }
    }

    //util methods
    ////
    protected String  setStringValue(String dest, String source) {
        return setStringValue(dest, source, true);
    }

    protected String setStringValue(String dest, String source, boolean clear) {
        String result;
        if (source != null) {
            result = source.trim();
        } else if (!clear) {
            result = null;
        } else result = dest;
        return result;
    }

    protected int getTestTechnique(TestTechnique testTechnique) {
        if (testTechnique == null) return 0;
        return testTechnique.isEqClass()?1:testTechnique.isBoundary()?2:0;
    }

    protected String appendString(String dest, String separator,
            String stringPrefix, ArrayList list) {
        if (list != null) {
            Iterator it = list.iterator();
            while(it.hasNext()) {
                String postfix = it.next().toString().trim();
                if (!postfix.equals("")) {
                    if (dest == null || dest.trim().equals("")) {
                        dest = stringPrefix + postfix;
                    } else if (!((dest.indexOf(separator + stringPrefix + postfix + separator) >= 0) || dest.startsWith(stringPrefix + postfix + separator) || dest.endsWith(separator + stringPrefix + postfix) || dest.equals(stringPrefix + postfix))) {
                        dest += separator + stringPrefix + postfix;
                    }
                }
            }
        }

        return dest;
    }

   /**
    * This method is overridden to return nothing.
    */
    protected String getImportForTestClass(String testpackage, String testclass) {
        return "";
    }

   /**
    * This method is overridden to implement JCK workaround for java.awt.event
    */
    protected String getTestPackageName(String testpackage, String testclass){
        if (testpackage!= null) {
            if (testpackage.startsWith("java.awt")) {
                if (testpackage.startsWith("java.awt.event")) {
                    testpackage = "java.awt.Event" + testpackage.substring(14);
                } else if (testpackage.startsWith("java.awt.color")) {
                    testpackage = "java.awt.Color" + testpackage.substring(14);
                } else if (testpackage.startsWith("java.awt.font")) {
                    testpackage = "java.awt.Font" + testpackage.substring(13);
                } else if (testpackage.startsWith("java.awt.image")) {
                    testpackage = "java.awt.Image" + testpackage.substring(14);
                }
            }
        }
        return super.getTestPackageName(testpackage, testclass);
    }

    protected String getClassFileName(String file) {
        return originalSourceName == null ? super.getClassFileName(file)
                                          : originalSourceName;
    }

    protected String getImportString(ArrayList imports) {
        if (imports == null) {
            return "";
        } else {
            Iterator it = imports.iterator();
            StringBuffer buf = new StringBuffer();
            String imp;
            while (it.hasNext()) {
                imp = it.next().toString().trim();
                if (imp != null && !imp.equals("")) {
                    buf.append("import ");
                    buf.append(imp);
                    buf.append(";\n");
                }
            }
            return buf.toString();
        }
    }

    protected String getTestGroupContext(TestGroup tg) {
        return new TGVisitor(tg).getContext();
    }

    protected String getTestGroupExecuteArgs(TestGroup tg) {
        return new TGVisitor(tg).getExecuteArgs();
    }

    public ArrayList parseArguments(ArrayList args)
            throws ParseArgumentException {
        return args;
    }

    public void registerOptions() {
    }

    public void resetOptions() {
    }

    public void applyOptionsValues() throws ParseArgumentException {
    }

    public void addOption(Option op) {
    }

    public void removeOption(Option op) {
    }

    public void setOptionsUsageInfo(String[] oui) {
    }

    public String[] getOptionsUsageInfo() {
        return new String[0];
    }

    public Option[] allOptions() {
        return new Option[0];
    }


    protected void fireGenerationEvent(TestGroup ti, String fileName) throws TestFileException {
    	try {
            IR.setAttrElem(ti, ExcludeListUtils.TestDescriptionURLAttrElemName, fileName);
            m_elCollector.addEntry(ti);
        } catch (IncorrectAttributesException e) {
            throw new TestFileException (e.toString());
        } catch (IOException ioe) {
            throw new TestFileException(ioe.toString());
        }
    }

    protected void fireGenerationEvent(TestCase ti, String fileName) throws TestFileException {
        try {
            IR.setAttrElem(ti, ExcludeListUtils.TestDescriptionURLAttrElemName, fileName);
            IR.setAttrElem(ti, ExcludeListUtils.TestCaseNameAttrElemName, ti.getID());
            m_elCollector.addEntry(ti);
        } catch (IncorrectAttributesException e) {
            throw new TestFileException (e.toString());
        } catch (IOException ioe) {
            throw new TestFileException(ioe.toString());
        }
    }


    protected LibAPIProperties getProperties() {
        return new LibAPIPropertiesImpl();
    }

    protected String getDestinationDir() {
        return BuildProperties.getString(getTCKDstDirVarName());
    }

    protected String getTCKDstDirVarName(){
        return "tck.classes.dir";
    }

    /**
     * Overrides {@link com.sun.jmpp.lib.JmppLibAPI#getJavaCopyrightBlock(String)}.
     *
     * @param sc_info source code control information. Ignored by this method, the value of
     *     the {@link com.sun.jmpp.lib.JmppLibAPI#scInfo} superclass' field is used instead.
     * @return completely formatted copyright block, ready to be inserted
     *     to a java sourse file without modification.
     */
    protected String getJavaCopyrightBlock(String sc_info) {
        // file, currentFileName are defined in JmppLibAPI
        String f = getOutputDir() + "/" +
            (isGeneratingJavaHead() ?
             getClassFileName(file) :
             getShortTestClassName() + "/" + currentFileName) +
            ".java";

        try {
            String crn = CopyrightManager.getCopyright(
                  // anchor ID
                CRN_JAVA_SHORT,
                  // source code control info
                scInfo,
                  // currently generated source
                f
            );
            if (copyright == null && crn != null) {
                CopyrightManager.logCrnOk("(MultiTestWriter) " + f);
                return crn;
            } else {
                return super.getJavaCopyrightBlock(sc_info);
            }
        } catch (CopyrightManager.Fault cf) {
            CopyrightManager.errorSkipCRN("(MultiTestWriter) " + cf.getMessage(), f);
            return super.getJavaCopyrightBlock(sc_info);
        }
    }

    protected String getHtmlCopyrightBlock() {
        String crn_link = getCopyrightLink();
        // htmlindex is defined in JmppLibAPI
        String f =
            getOutputDir() + "/" +
            getShortTestClassName() +
            "/" + htmlindex + ".html";

        try {
            String crn = CopyrightManager.getCopyright(
                  // anchor ID
                CRN_HTML_SHORT,
                  // macros to expand
                new String[][] {
                    { MACRO_SC_INFO,       scInfo   },
                    { MACRO_FULL_CRN_LINK, crn_link }
                }
            );
            if (crn != null) {
                CopyrightManager.logCrnOk("(MultiTestWriter) " + f);
                return crn;
            } else {
                return super.getHtmlCopyrightBlock() + "\n";
            }
        } catch (CopyrightManager.Fault cf) {
            CopyrightManager.errorSkipCRN("(MultiTestWriter) " + cf.getMessage(), f);
	    return super.getHtmlCopyrightBlock() + "\n";
        }
    }

    protected TDEntriesCollector createTDEntriesCollector() {
        return new TDEntriesCollector();
    }

    protected TestDescriptionIR createTestDescriptionIR() {
        TestDescriptionIR tdIR = super.createTestDescriptionIR();
        tdCollector.putIntoTD(tdIR);
        tdCollector.clear();
        return tdIR;
    }

    //Inner classes
    ////

    public class IRContainer {
        protected TestSuite testSuite;
        protected ArrayList testGroups;
        protected Iterator testGroupIterator;

        protected String m_class;
        protected String m_package;
        protected String m_outputDir = ".";

        public String getTestedClass() {
            return m_class;
        }

        public String getTestedPackage() {
            return m_package;
        }

        public String getOutputDir() {
            return m_outputDir;
        }

        /**
         * Detects the tested class under test for the passed TestGroup.
         * Returned value will be used for calculation of the test package
         * name. So for some kinds of tests returned value will be different
         * from real class name under test.
         * <br>
         * It returns the value of "testSubPackage" AttrElem if specified.
         * But usually the value of TestedClass specified for TestGroup
         * is returned.
         *
         * @throws TestFileException if "testSubPackage" AttrElem is not
         *         specified and either tg == null, or TGDocumentation == null,
         *         or TestedClass == null.
         */
        protected String detectTestedClass(TestGroup tg)
                throws TestFileException {
            if(tg == null) {
                throw new TestFileException(
                     "Cannot detect TestedClass: testgroup is null");
            }

            // looks for AttrElem first.
            // if defined, its value is returned.
            String testSubPackage =
                    IR.getAttrElem(IR.testSubPackageAttrElemName, tg);
            if (testSubPackage != null) {
                return testSubPackage.trim();
            }

            // AttrElem is not defined, TestedClass should be set
            if(tg.getTGDocumentation() == null) {
                throw new TestFileException(
                     "Cannot detect TestedClass: testgroup doc is not defined");
            }

            String testedClass = tg.getTGDocumentation().getTestedClass();
            if (testedClass != null) {
                return testedClass.trim();
            } else {
                throw new TestFileException(
                     "Cannot detect TestedClass: this element is not defined");
            }
        }

        protected void setClass(String value) throws TestFileException {
            if (value == null) {
               return;
            }

            if (m_class != null) {
                //check
                ////
                if (!m_class.equals(value.trim())) {
                    throw new TestFileException(LibResHandler.getResStr
                    ("testgen.error.test.multipleclasses"));
                }
            } else {
                m_class = value.trim();
            }
        }

        protected void setPackage(String value) throws TestFileException {
            if (value == null) {
                    throw new TestFileException(LibResHandler.getResStr(
                    "testgen.error.test.nullpackage"));
            }

            if (m_package != null) {
                //check
                ////
                if (!m_package.equals(value.trim())) {
                    throw new TestFileException(LibResHandler.getResStr("testgen.error.test.multiplepackages"));
                }
            } else {
                m_package = value.trim();
            }
        }

        public IRContainer() {
           testGroups = new ArrayList();
           testSuite = null;
        }

        void init(IRObj[] trees) throws TestFileException {
            for (int i = 0; i<trees.length; i++) {
                if (trees[i] instanceof TestSuite) {
                    setTestSuite((TestSuite)trees[i]);
                } else if (trees[i] instanceof TestGroup) {
                    m_outputDir = IR.getAttrElem("OutputDir", (TestGroup)trees[i]);
                    if (m_outputDir == null || m_outputDir.equals("")) {
                        m_outputDir = ".";
                    }
                    setClass(detectTestedClass((TestGroup)trees[i]));
                    setPackage(((TestGroup)trees[i]).getTGDocumentation().getTestedPackage());
                    testGroups.add(trees[i]);
                } else {
                    throw new TestFileException(LibResHandler.getResStr(
                        "testgen.error.unknownIR", trees[i].toString()));
                }
            }

            if (testGroups.isEmpty()) {
                throw new TestFileException(LibResHandler.getResStr(
                        "testgen.error.noroot"));
            }
        }


        protected void setTestSuite(TestSuite value) throws TestFileException {
            if (testSuite == null) {
                testSuite = value;
            } else {
                throw new TestFileException(LibResHandler.getResStr(
                        "testgen.error.multiplelinks"));
            }
        }

        protected TestSuite createDefaultLinkTestSuite(String classUnderTest) {
            TestSuite result = new TestSuiteImpl(
                    "Test Specifications and Descriptions for " + classUnderTest,
                    "Test for " + classUnderTest,
                    TestSuite.LIST_FORMAT, "");
            return result;
        }

        public TestSuite getTestSuite() {
            return (testSuite != null)?
                testSuite:createDefaultLinkTestSuite(m_class);
        }

        public boolean hasMoreTestGroups() {
            if (testGroupIterator == null)
                testGroupIterator = testGroups.iterator();
            return testGroupIterator.hasNext();
        }

        public TestGroup getTestGroup() {
            if (testGroupIterator == null)
                testGroupIterator = testGroups.iterator();
            return (TestGroup)testGroupIterator.next();
        }
    }
	
	/**
	*  Adds conflict files or clear file set if parameter is null
	*/    
    public void setConflictFiles(HashSet files) {
    	if (files != null) 
	    	conflictFiles.addAll(files);
		else 
			conflictFiles.clear();    
    }
	
    /**
	*	Checks whenever file is in conflict set
	*/	
    public boolean isInConflictMode(String file) {
		return conflictFiles.contains(file);
    }
	
	/**
	*	This method will help setting data after clonning object. It's
	*	useful in derived classes. 
	*/
	protected void setOriginal(MultiTestWriter original) {
	}
		
	/**
	* Insert mark after top list
	*/	
    protected void generateHTMLTopListOfMethods(Object[] methodsArray) {
        super.generateHTMLTopListOfMethods(methodsArray);
        if (isInConflictMode(htmlindex)) 
			printString(EmitterManager.HtmlConflictModeIntf.AFTER_TOPLIST);
    }
	
	/**
	*	Insert mark after html table
	*/	
    protected  void generateHTML() {
		super.generateHTML();
        if (isInConflictMode(htmlindex)) 
			printString(EmitterManager.HtmlConflictModeIntf.AFTER_TABLE);
    }
	
	/**
	* Helper method. Prints string into internal html buffer.	
	*/
    protected void printString(String str) {
        StringBuffer savedBuffer = outBuffer;
        outBuffer = htmlBuffer;
        L(str);
        outBuffer = savedBuffer;
    }

}


class LibAPIPropertiesImpl implements  LibAPIProperties {


    public LibAPIPropertiesImpl() {
    }

    /**
     * Returns copyright notice to be inserted into test code.
     */
    public String getCopyrightNotice() {
        return BuildProperties.getPrefixString("testgen", "test.copyrightNotice", "");
    }

    /**
     * Returns the default imports.
     */
    public String getDefaultImports() {
        String resultImports = "";
        String savedImports = BuildProperties.getPrefixString
            ("testgen", "test.defaultImports", "");
        if (savedImports == null || savedImports.trim().equals("")) {
            return "";
        } else {
            StringTokenizer tok =
                new StringTokenizer(savedImports, new String(","));
            while(tok.hasMoreTokens()) {
                resultImports += "import " + tok.nextToken().trim() + ";\n";
            }
            return resultImports.substring(0, resultImports.length()-1);
        }
    }

    /**
     * Returns hastable containing baseClass - execute arguments pairs.
     */
    public Hashtable getBaseClassExecuteArgs() {
        Hashtable result = new Hashtable();
        ArrayList classes =  getBaseClassList();
        Iterator it = classes.iterator();
        while (it.hasNext()) {
            String shortClassName = (String)it.next();
            String arguments = BuildProperties.getString("test.baseClass." + shortClassName.trim()
                + ".executeArgs");
            if (arguments != null
                    && arguments.trim().compareTo("") != 0) {
                result.put(shortClassName, arguments);
            }
        }

        return result;
    }


    /**
     * Returns default keywords.
     */
    public String getDefaultKeywords() {
        return getDefaultKeywordsImpl("test.defaultKeywords");
    }

    /**
     * Returns default rmic keywords.
     */
    public String getDefaultRmicKeywords() {
        return getDefaultKeywordsImpl("test.defaultRmicKeywords");
    }


    protected ArrayList getBaseClassList() {

        ArrayList result = new ArrayList();
        String propName = "test.baseClass";

        Enumeration e = BuildProperties.propertyNames(propName);
        while (e.hasMoreElements()) {
            String baseClass = (String)e.nextElement();
            if  (baseClass.endsWith(".className")) {
                int start = propName.length()+1;
                int end = baseClass.lastIndexOf(".className", baseClass.length());
                result.add(baseClass.substring(start, end));
            } else if (baseClass.endsWith(".executeArgs")) {
                int start = propName.length()+1;
                int end = baseClass.lastIndexOf(".executeArgs", baseClass.length());
                result.add(baseClass.substring(start, end));
            }
        }
        return result;

    }


    /**
     * Returns hashtable containing baseclass name - full baseclass name paris
     */
    public Hashtable getBaseClasses() {
        Hashtable result = new Hashtable();

        ArrayList classes =  getBaseClassList();
        Iterator it = classes.iterator();
        while (it.hasNext()) {
            String shortClassName = (String)it.next();
            String fullClassName = BuildProperties.getString("test.baseClass."
                    + shortClassName + ".className");
            if  (fullClassName != null && !fullClassName.trim().equals("")) {
                result.put(shortClassName, fullClassName);
            }
        }
        return result;
    }

    /**
     * Returns package prefix to be appended into a package name
     * of the tests generated.
     */
    public String getPackagePrefix() {
        String prefix = BuildProperties.getPrefixString("testgen", "test.packagePrefix", "").trim();
        if (prefix == null) {
            return "";
        } else {
            // check that prefix is valid Java package name
            if (prefix.indexOf("..") >= 0) {
                throw new InvalidPropertyException("test.packagePrefix", "Invalid package name: "
                            + prefix);
            }
            if (prefix.startsWith("java.")) {
                throw new InvalidPropertyException("test.packagePrefix", "Invalid package name: "
                            + prefix + " (\"java\" name is reserved)");
            }
            StringTokenizer tok = new StringTokenizer(prefix, ".");
            while (tok.hasMoreTokens()) {
                String subpackage = tok.nextToken();
                for (int i = 0; i < subpackage.length(); i++) {
                if (! ((i==0) ? Character.isJavaIdentifierStart(subpackage.charAt(i))
                              : Character.isJavaIdentifierPart(subpackage.charAt(i))) ) {
                    throw new InvalidPropertyException("test.packagePrefix", "Invalid package name: "
                            + subpackage);
                    }
                }
            }
            return prefix;
        }

    }

    /**
     * Returns maximum file name length allowed for output files.
     */
    public int getMaxFileNameLength() {
        return BuildProperties.getPrefixInt("testgen", "filename.maxLength", 0);
    }

    /**
     * Returns short html copyright notice
     */
    public String getHtmlCopyrightNotice() {
        return BuildProperties.getPrefixString("testgen", "html.copyrightNotice", "");
    }


    protected String getDefaultKeywordsImpl(String propertyName) {
        String keywords = BuildProperties.getPrefixString("testgen", propertyName, "");
        if (keywords == null || keywords.trim().length() == 0) {
            return "";
        } else {
            StringTokenizer tok = new StringTokenizer(keywords, " ");
            while (tok.hasMoreTokens()) {
                String keyword = tok.nextToken();
                for (int i=0; i<keyword.length(); i++) {
                    // We assume JavaTest keywords could consist of either letters or digits
                    if (!Character.isLetterOrDigit(keyword.charAt(i))) {
                        throw new InvalidPropertyException(propertyName, "Invalid keyword: "
                                    + keyword);
                    }
                }
            }
            return keywords;
        }
    }

    protected String getBaseClassShortName(String baseClassName) {
        return baseClassName.substring(baseClassName.lastIndexOf(".") + 1);
    }
	
}
