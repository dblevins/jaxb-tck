/*
 * Copyright (c) 2003, 2020 Oracle and/or its affiliates. All rights reserved.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0, which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the
 * Eclipse Public License v. 2.0 are satisfied: GNU General Public License,
 * version 2 with the GNU Classpath Exception, which is available at
 * https://www.gnu.org/software/classpath/license.html.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0
 */

package com.sun.tgxml.tools.jmppconv.processors.parser;

import java.io.File;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Enumeration;
import java.util.Comparator;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Stack;
import java.util.Vector;

import com.sun.jmpp.JmppException;
import com.sun.jmpp.lib.JmppLibTest;
import com.sun.jmpp.lib.jtf.JTF_Slot;
import com.sun.tgxml.tjtf.api.attributes.AttributesFactory;
import com.sun.tgxml.tjtf.api.attributes.TestCaseAttributes;
import com.sun.tgxml.tjtf.api.exceptions.TestFileException;
import com.sun.tgxml.tjtf.api.tests.TestCase;
import com.sun.tgxml.tjtf.api.tests.TestFactory;
import com.sun.tgxml.tjtf.api.tests.TestGroup;
import com.sun.tgxml.tjtf.tools.BuildProperties;
import com.sun.tgxml.tools.jmppconv.processors.parser.IRTDGenerator;
import com.sun.tgxml.tools.testgen.LibUtils;
import com.sun.tgxml.util.IR;

/**
 * This class implements the test case variant generation engine:
 * <ul>
 * <li>provides means to register template parameters on which current
 *     template depends, i.e. to add them to the list of dependences</li>
 * <li>automatically creates full iterators over parameter values</li>
 * <li>splits each test which would be generated by the companion Jmpp library
 *     into test cases and, further, into test case variants</li>
 * <li>provides mechanisms to automatically name test cases and variants</li>
 * <li>provides mechanisms to generate test case sources content in dependence
 *     on parameters' current values
 * <li>automatically assigns necessary TGXML IR attributes to generated test cases depending
 *     on parameters' values<li>
 * </ul>
 *
 *
 * @author Konstantin S. Bobrovsky
 */
public class IRTDParamGenerator extends IRTDGenerator {

    /*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
    /* Inner classes */
    /*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/

    /**
     * java.util.Comparator implementation for comparing template parameters
     * by either their weights or sortKeys.
     */
    protected static class TPComparator implements Comparator {
        public final static boolean BY_SORT_KEY = false;
        public final static boolean BY_WEIGHT = true;

        private boolean sortByWeight;

        /**
         * Constructor.
         *
         * @param sort_by_weight defines comparison field for the
         *        {@link #compare(Object, Object)} method. If true,
         *        the comparison is made by weight, otherwise - by sortKey.
         */
        public TPComparator(boolean sort_by_weight) {
            this.sortByWeight = sort_by_weight;
        }

        public int compare(Object o1, Object o2) {
            TemplateParameter param1 = (TemplateParameter)o1;
            TemplateParameter param2 = (TemplateParameter)o2;
            int i1;
            int i2;

            if (sortByWeight) {
                i1 = param1.getWeight();
                i2 = param2.getWeight();
            } else {
                i1 = param1.getSortKey();
                i2 = param2.getSortKey();
            }
            long diff = (long)i1 - (long)i2;
            return (diff < 0 ? -1 : (diff > 0 ? 1 : 0));
        }

        public boolean equals(Object obj) {
            return this == obj;
        }
    }

    /**
     * Element of the code region condition stack
     */
    protected static class PStackElem {
        public String paramID;
        public boolean paramsOK;

        public PStackElem(String param_id, boolean params_ok) {
            paramID  = param_id;
            paramsOK = params_ok;
        }
    }

    /*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
    /* Constants */
    /*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/

    public final static String TC_NAME      = "test_case_name";
    public final static String TC_VAR_NAME  = "test_case_var_name";
    public final static String TC_VAR_ORDER = "test_case_var_order";

    private final static int NM_FIRST = 1;

    /**
     * Identifies the main naming scheme (mode) described in the SDD:
     * TC/TCV name is constructed from current parameter values'
     * symbols. This naming scheme guarantees that the set of
     * generated test case names will preserve (i.e. contain) the
     * original set of test case names which would be generated
     * without template parameters. This is the default naming mode.
     */
    public final static int NM_DEFAULT_PRESERVE = NM_FIRST;

    /**
     * Identifies a naming mode. This mode's difference from
     * {@link #NM_DEFAULT_PRESERVE} scheme is that at least one
     * parameter value symbol is always appended to the original
     * test case name. I.e. this sheme does not preserve the original
     * test case names.
     */
    public final static int NM_DEFAULT_APPEND = NM_DEFAULT_PRESERVE + 1;

    /**
     * Identifies a naming mode. This mode works similarly to
     * {@link #NM_DEFAULT_PRESERVE} but no symbols are ever removed
     * from the end of test case name, and the names are all of the
     * fixed length.
     */
    public final static int NM_FIXED = NM_DEFAULT_APPEND + 1;

    private final static int NM_LAST  = NM_FIXED;

    /**
     * Default package to search template parameter classes in.
     */
    public final static String DEFAULT_PARAM_PCKG  = "com.sun.jmpp.param";

    /**
     * Build property name to specify alternative template parameter packages
     */
    public final static String PARAM_PCKG_PROPERTY = "jmppconv.parser.param_pckg";

    private final static int OP_LT  = 1;
    private final static int OP_EQ  = 2;
    private final static int OP_LTE = 3;
    private final static int OP_GT  = 4;
    private final static int OP_NE  = 5;
    private final static int OP_GTE = 6;

    /*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
    /* Fields */
    /*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/

    /**
     * Underlying Jmpp library which produces initial tests,
     * split by this generator
     */
    private JmppLibTest lib;

    private HashMap id2param = new HashMap();
    private ArrayList paramPckgList = new ArrayList();
    private ArrayList strongParamList = new ArrayList();
    private ArrayList weakParamList = new ArrayList();
    private ArrayList allParamList = new ArrayList();

    private TemplateParameter[] strongParams;
    private TemplateParameter[] weakParams;
    private TemplateParameter[] weakParamsByWeight;
    private JTF_Slot strongIter;
    private JTF_Slot weakIter;

    private HashMap testCaseProps = new HashMap();
    private Stack pStack = new Stack();
    private boolean paramsOK = true;

    private boolean iteratorsCreated = false;

    private int namingMode = NM_DEFAULT_PRESERVE;


    /*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
    /* Constructors */
    /*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/

    /**
     * Constructor.
     *
     * @param lib the Jmpp library instance which performs test generation
     */
    public IRTDParamGenerator(JmppLibTest lib) {
        this.lib = lib;
        populateParamPckgList();
    }

    /**
     * @return the complementary instance of <code>JmppLibTest</code> which this
     *   generator has been constructed with, and which actually performs
     *   test generation
     */
    protected JmppLibTest getJmppLib() {
        return lib;
    }

    /*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
    /* Template parameter management and combination generation methos */
    /*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/

    /**
     * Constructs and adds new template parameter specified by given
     * parameter class name to the "dependency list", which will drive combination
     * generation.
     *
     * @param param_id 
     * @throws JmppException 
     */
    public void addDependence(String param_id) throws JmppException {
        if (id2param.get(param_id) != null) {
            error("parameter already added: " + param_id);
        }
        TemplateParameter param = createParameter(param_id);

        if (param == null) {
            error("Could not find parameter class: " + param_id);
        }
        addParameter(param_id, param);
    }

    /**
     * Adds a new template parameter on which current template depends.
     *
     * @param param template parameter instance
     * @throws JmppException (unchecked) if specified parameter is unknown or
     *     already added
     */
    public void addDependence(TemplateParameter param)
        throws JmppException
    {
        String param_id = param.getName();
        if (id2param.get(param_id) != null) {
            error("parameter already added: " + param_id);
        }
        if (id2param.values().contains(param)) {
            error("parameter instance already added: " + param_id);
        }
        addParameter(param_id, param);
    }

    /**
     * @return <code>true</code> if current values of all dependant parameters
     *    satisfy the conditions imposed by the stack of <code>begin...</code>
     *    conditional region markers at the place of invocation. Otherwise returns
     *    <code>false</code>.
     */
    public boolean paramConditionsSatisfied() {
        return paramsOK;
    }

    private void beginX(String param_id, String val_mnemo, int op_mask) throws JmppException {
        TemplateParameter param = getExistingParameter(param_id);
        pStack.push(new PStackElem(param_id, paramsOK));
        int res = 1 << (param.compareValueTo(val_mnemo) + 1);
        /*
         * compareValueTo can return -1(lt), 0(eq) or 1(gt), thus
         * 'res' at this point can be 1(lt), 2(eq), 4(gt)
         */
        paramsOK = paramsOK && ((res & op_mask) != 0);
    }

    /**
     * Marks the code region from the place of invocation till corresponding
     * <code>end()</code> marker as the region to be executed only if the
     * current value of given parameter is less than the value with given
     * mnemonics.
     *
     * @param param_id  parameter ID
     * @param val_mnemo value mnemonics
     * @throws JmppException (unchecked) if either parameter or mnemonics are
     *     unknown
     */
    public void beginLT(String param_id, String val_mnemo) throws JmppException {
        beginX(param_id, val_mnemo, OP_LT);
    }

    public void beginLTE(String param_id, String val_mnemo) throws JmppException {
        beginX(param_id, val_mnemo, OP_LTE);
    }

    public void beginEQ(String param_id, String val_mnemo) throws JmppException {
        beginX(param_id, val_mnemo, OP_EQ);
    }

    public void beginNE(String param_id, String val_mnemo) throws JmppException {
        beginX(param_id, val_mnemo, OP_NE);
    }

    public void beginGTE(String param_id, String val_mnemo) throws JmppException {
        beginX(param_id, val_mnemo, OP_GTE);
    }

    public void beginGT(String param_id, String val_mnemo) throws JmppException {
        beginX(param_id, val_mnemo, OP_GT);
    }

    private void beginBool(String param_id, boolean val) throws JmppException {
        TemplateParameter param = getExistingParameter(param_id);
        pStack.push(new PStackElem(param_id, paramsOK));
        paramsOK = paramsOK && (param.compareValueTo(val) == 0);
    }

    /**
     * Starts conditional code region if the specified parameter is currently "true".
     *
     * @param param_id parameter ID
     * @throws JmppException (unchecked) if either parameter is unknown or does not
     *     support comparison to boolean values.
     */
    public void beginTRUE(String param_id) throws JmppException {
        beginBool(param_id, true);
    }

    /**
     * Starts conditional code region if the specified parameter is currently "false".
     *
     * @param param_id parameter ID
     * @throws JmppException (unchecked) if either parameter is unknown or does not
     *     support comparison to boolean values.
     */
    public void beginFALSE(String param_id) throws JmppException {
        beginBool(param_id, false);
    }

    /**
     * Marks the end of conditional template code region.
     *
     * @param param_id ID of the parameter, for which the conditional region was started.
     * @throws JmppException (unchecked) if parameter is unknown, the conditional region has not been started or
     *   if a call to this methods interleaves with the begin...() end() pair for another parameter
     */
    public void end(String param_id) throws JmppException {
        if (pStack.isEmpty()) {
            error("end() without begin...(), parameter: " + param_id);
        }
        PStackElem elem = (PStackElem)pStack.pop();

        if (!param_id.equals(elem.paramID)) {
            error("end() without matching begin...(), parameter: " + param_id);
        }
        paramsOK = elem.paramsOK;
    }

    /**
     * Sets test case/test case variant naming mode.
     *
     * @param mode the mode indentifier. Can be one of the NM_... constants
     *     defined in this class
     * @throws JmppException (unchecked) if the mode is unknown
     */
    public void setNamingMode(int mode) {
        if (mode < NM_FIRST || mode > NM_LAST) {
            error("unknown naming mode: " + mode);
        }
        this.namingMode = mode;
    }

    /**
     * Retrieves current naming mode.
     *
     * @return current naming mode
     * @see #setNamingMode(int)
     */
    public int getNamingMode() {
        return namingMode;
    }

    /**
     * @return array of weak parameters sorted by sort key
     */
    public TemplateParameter[] getWeakParameters() {
        return weakParams;
    }

    /**
     * @return array of strong parameters sorted by sort key
     */
    public TemplateParameter[] getStrongParameters() {
        return strongParams;
    }

    private void addParameter(String param_id, TemplateParameter param) {
        if (iteratorsCreated) {
            error("parameters can only be added within makeOut method");
        }
        ArrayList l = param.isStrong() ? strongParamList : weakParamList;
        l.add(param);
        id2param.put(param_id, param);
    }

    /**
     * @param param_id parameter ID
     * @return a parameter with given ID. If such parameter has already been
     *     added to the list of dependences, then returns this parameter.
     *     Otherwise treats the ID as short parameter class name and tries to
     *     load and instantiate the class. <code>null</code> is returned if
     *     all the above attempts failed.
     * @throws JmppException (unchecked)
     */
    public TemplateParameter getParameter(String param_id)
        throws JmppException
    {
        TemplateParameter res = (TemplateParameter)id2param.get(param_id);
        if (res != null) {
            return res;
        }
        return createParameter(param_id);
    }

    /**
     * @param param_id parameter ID
     * @return a parameter with given ID which has been added to the dependences list
     * @throws JmppException (unchecked) if parameter is unknown or has not been
     *     added to the list
     */
    public TemplateParameter getExistingParameter(String param_id)
        throws JmppException
    {
        TemplateParameter res = (TemplateParameter)id2param.get(param_id);

        if (res == null) {
            error("unknown parameter: " + param_id);
        }
        return res;
    }

    /**
     * Creates an instance of parameter with given ID. For each package in
     * {@link #DEFAULT_PARAM_PCKG} and packages specified via {@link #PARAM_PCKG_PROPERTY}
     * property (in this order), appends the package name to the parameter ID
     * and tries to load and instantiate a class with the resulting full name.
     * Than casts the instance to {@link TemplateParameter} class.
     *
     * @param param_id parameter ID
     * @return the {@link TemplateParameter} instance created
     * @throws JmppException (unchecked) if the instance could not be created.
     */
    protected TemplateParameter createParameter(String param_id) {
        for (int i = 0; i < paramPckgList.size(); i++) {
            String s;
            Class c = null;
            String class_name = (String)paramPckgList.get(i) + "." + param_id;
            TemplateParameter param = null;

            try {
                c = Class.forName(class_name);
                param = (TemplateParameter)c.newInstance();
            } catch (ClassNotFoundException cnfe) {
                // ignore - try another package (if any)
            } catch (InstantiationException ie) {
                ie.printStackTrace(System.err);
                error("InstantiationException thrown: " + ie.getMessage());
            } catch (IllegalAccessException iae) {
                iae.printStackTrace(System.err);
                error("IllegalAccessException thrown: " + iae.getMessage());
            } catch (ClassCastException cce) {
                s = "class " + c.getName() + " is not a sub-class of ";
                error(s + TemplateParameter.class.getName());
            }
            if (param != null) {
                return param;
            }
        }
        return null;
    }

    public String getTestCaseProperty(String prop_name) {
        return (String)testCaseProps.get(prop_name);
    }

    public void setTestCaseProperty(String prop_name, String prop_val) {
        testCaseProps.put(prop_name, prop_val);
    }

    private static String[] split(String s, char delim) {
        String str = s;
        if (str == null) {
            return null;
        }
        Vector v = new Vector();

        for(int ind = str.indexOf(delim); ind >= 0; ind = str.indexOf(delim)) {
            if (ind > 0) {
                v.addElement(str.substring(0, ind));
            }
            str = str.substring(ind + 1);
        }
        if (str.length() > 0) {
            v.addElement(str);
        }
        String[] res = new String[v.size()];
        v.copyInto(res);
        return res;
    }

    /**
     * Constructs the internal list of packages to search for parameter
     * classes in.
     */
    private void populateParamPckgList() {
        paramPckgList.add(DEFAULT_PARAM_PCKG);
        String pckg_prop = BuildProperties.getString(PARAM_PCKG_PROPERTY);

        if (pckg_prop != null) {
            String[] pckg_arr = split(pckg_prop, File.pathSeparatorChar);

            for (int i = 0; i < pckg_arr.length; paramPckgList.add(pckg_arr[i++]));
        }
    }

    /**
     * Constructs a string identifier for a combination of current values
     * of given template parameters. Implementation guarantees that
     * produced identifiers will be unique for all possible combinations.
     * Override this method to change test case and test case variant naming scheme.
     *
     * @param params array of parameters to construct combination ID for
     * @param mode naming mode indentifier
     * @return a string which uniquely identifies the combination of
     *     current values of the parameters.
     * @see #setNamingMode(int)
     */
    public static String getCombinationID(TemplateParameter[] params, int mode) {
        boolean last_skipped = true;
        String res = "";

        for (int i = params.length - 1; i >= 0 ; i--) {
            TemplateParameter param = params[i];
            TemplateParameter.Value val = param.getValue();

            if (mode == NM_DEFAULT_PRESERVE || mode == NM_DEFAULT_APPEND) {

                int min_i = mode == NM_DEFAULT_PRESERVE ? -1 : 0;
                int ind = param.getValueIndex(val);

                if (last_skipped && ind == 0 && i > min_i) {
                    continue;
                }
                last_skipped = false;
            }
            res = "" + val.getSymbol() + res;
        }
        return res;
    }

    /**
     * Implements the algorithm of calculating the <code>varOrder</code>
     * attribute basing on given parameters and their state.
     *
     * @param params the parameters
     * @return a string representing the calculated attribute
     */
    public static String getVarOrder(TemplateParameter[] params) {
        int weight_accum = 1;
        float res = 0.0f;

        for (int i = 0; i < params.length; i++) {
            TemplateParameter param = params[i];

            res += param.getValueWeightIndex(param.getValue()) * weight_accum;
            weight_accum *= param.getValueCount();
        }
        return res == 0.0f ? "0.0" : Float.toString(res/100.0f);
    }

    /**
     * @param file_name a file name
     * @return the file name modified the following way: a suffux identifying
     *     current combination of weak template parameters is added before the
     *     <code>.&lt;extension&gt;</code> of the filename (or to the end of the
     *     name if the extension is absent)
     */
    public String getSourceNameVariant(String file_name) {
        // if template spawns test case variants, then
        // add variant name to the source name
        String tc_var_name = getTestCaseProperty(TC_VAR_NAME);
        return LibUtils.addVariantNameToSource(file_name, tc_var_name);
    }

    protected static TemplateParameter[] createParamArray(ArrayList l) {
        return (TemplateParameter[])l.toArray(new TemplateParameter[] {});
    }

    protected static void setParameterValues(JTF_Slot iter, TemplateParameter[] params) {
        for (int i = 0; i < params.length; i++) {
            params[i].setTo(iter.subSlot(i).curVal());
        }
    }

    /**
     * Creates a "full" iterator over combinations of values of given parameters.
     *
     * @param params the parameters
     * @return created iterator.
     */
    protected static JTF_Slot createIterator(TemplateParameter[] params) {
        if (params == null || params.length == 0) {
            return null;
        }
        JTF_Slot[] sub_iters = new JTF_Slot[params.length];
        Arrays.sort(params, new TPComparator(TPComparator.BY_SORT_KEY));

        for (int i = 0; i < params.length; i++) {
            sub_iters[i] = new JTF_Slot(params[i].getValueCount());
        }
        return JTF_Slot.multiplyFULL(sub_iters);
    }

    /**
     * Reads current lists of weak and strong parameters
     * (populated via <code>addDependence</code> calls made from the template),
     * and constructs two interanal full iterators over parameter value combinations.
     * After this method is called, no more parameters can be added to the dependence
     * lists.
     */
	public void initIterators() {
        strongParams = createParamArray(strongParamList);
        weakParams   = createParamArray(weakParamList);
        strongIter = createIterator(strongParams);
        weakIter   = createIterator(weakParams);
        weakParamsByWeight = new TemplateParameter[weakParams.length];
        System.arraycopy(weakParams, 0, weakParamsByWeight, 0, weakParams.length);
        Arrays.sort(weakParamsByWeight, new TPComparator(TPComparator.BY_WEIGHT));
        allParamList.addAll(strongParamList);
        allParamList.addAll(weakParamList);
        iteratorsCreated = true;
    }

    /**
     * This is a method which actually "splits" a single test generated
     * by the companion Jmpp library. It iterates over all combinations
     * of strong paramter's values generating one test case per combination
     * (cycle1). Then for each test case it iterates over all combinations
     * of weak paramter's values generating one variant of current test case
     * per combination (cycle2). During each iteration of cycle1, cycle2 is
     * fully iterated, and during each iteration of cycle2, the
     * {@link com.sun.jmpp.lib.JmppLibTest#generateTest(int)} method of the
     * Jmpp library is invoked. Before calling this method, some internal
     * attributes are set which are then used by the library for naming split
     * tests (test cases) and variants of source files of the test cases.
     * 
     * @param testNumber the number of current test to be split
     * @throws TestFileException 
     */
    public void splitTest(int testNumber) throws TestFileException {
        TemplateParameter[] s_params = getStrongParameters();
        TemplateParameter[] w_params = getWeakParameters();

        while (strongIter == null || strongIter.genNext()) {
            ArrayList test_cases = new ArrayList();
            setParameterValues(strongIter, s_params);
            setTestCaseProperty(TC_NAME, getCombinationID(s_params, namingMode));

            while (weakIter == null || weakIter.genNext()) {
                String tc_var_name = null;
                String tc_var_order = null;

                if (weakIter != null) {
                    setParameterValues(weakIter, w_params);
                    tc_var_name  = "v" + getCombinationID(w_params, namingMode);
                    tc_var_order = getVarOrder(weakParamsByWeight);
                    setTestCaseProperty(TC_VAR_NAME,  tc_var_name);
                    setTestCaseProperty(TC_VAR_ORDER, tc_var_order);
                }
                updateAutoTestCaseAttributes(allParamList);

                getJmppLib().generateTest(testNumber);

                if (!getJmppLib().skipTest) { 
                    TestCase tc = irCreateTestCase(tc_var_name, tc_var_order);
                    test_cases.add(tc);
                    irFillTestCaseAttributes(tc, allParamList);
                }
                cleanupTestCaseAttributes(getJmppLib());

                if (weakIter == null) {
                    break;
                }
            }
            if (weakIter != null) {
                weakIter.reset();
            }
            if (test_cases.size() > 0) {
                updateAutoTestGroupAttributes(allParamList);
                TestGroup tg = irCreateTestGroup();
                irFillTestGroupAttributes(tg, allParamList);
                tg.setTestCases(test_cases);
                storeRoot(tg);
            }
            cleanupTestGroupAttributes(getJmppLib());

            if (strongIter == null) {
                break;
            }
        }
        if (strongIter != null) {
            strongIter.reset();
        }
    }

    /**
     * Simply throws a JmppException with given message.
     *
     * @param msg the message
     */
    private static void error(String msg) {
        throw new JmppException(msg);
    }

    /*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/
    /* IR creation/management methods */
    /*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/

    /**
     * This method is overriden so that it would do nothing,
     * since test groups and their test cases are now created
     * during test generation, not after it's done.
     *
     * @param lib Jmpp library
     * @param tg  test group
     * @return <code>null</code> (always)
     */
    protected ArrayList createTGTestCases(JmppLibTest lib, TestGroup tg) {
        return null;
    }

    /**
     * This method is overriden so that it would do nothing,
     * since test groups and their test cases are now created
     * during test generation, not after it's done.
     *
     * @param lib Jmpp library
     */
    public void makeTD(JmppLibTest lib) {}

    protected TestGroup irCreateTestGroup() throws TestFileException {
        JmppLibTest jmpp_lib = getJmppLib();
        TestGroup tg = TestFactory.createTestGroup();
        tg.setID(jmpp_lib.test);
        tg.setTGDocumentation(createTGDocumentation(jmpp_lib));
        return tg;
    }

    /**
     * Gives every TP from a list a chance to update attributes of the test case
     * which will be generated immediately thereafter. This method is invoked
     * before the <code>makeTest()</code> which actually generates test case source
     * files.
     * 
     * @param param_list the list of template parameters
     * @see TemplateParameter#updateTestcaseAttributes(AttributeSet,java.util.ArrayList)
     */
    private void updateAutoTestCaseAttributes(ArrayList param_list) {
        AttributeSet attr_set = createTCAttributeSet();
        for (int i = 0; i < param_list.size(); i++) {
            TemplateParameter param = (TemplateParameter)param_list.get(i);
            param.updateTestcaseAttributes(attr_set, (ArrayList)param_list.clone());
        }
    }
    
    /**
     * Gives every TP from a list a chance to update attributes of the test group
     * which has just been generated. This method is invoked after all test cases
     * of the test group has been generated.
     * 
     * @param param_list the list of template parameters
     * @see TemplateParameter#updateTestGroupAttributes(AttributeSet,java.util.ArrayList)
     */
    private void updateAutoTestGroupAttributes(ArrayList allParamList) {
        AttributeSet attr_set = createTGAttributeSet();
        for (int i = 0; i < allParamList.size(); i++) {
            TemplateParameter param = (TemplateParameter)allParamList.get(i);
            param.updateTestGroupAttributes(attr_set, (ArrayList)allParamList.clone());
        }
    }

    
    /**
     * Creates a <code>TestCase</code> TGXML IR object for the test case
     * currently being generated. Also, fills in its code set, documentation and
     * variant ID characteristics.
     *
     * @param var_name  test case variant name
     * @param var_order test case variant order
     * @return the <code>TestCase</code> instance created
     * @throws TestFileException if the instance could not be created
     */
    protected TestCase irCreateTestCase(String var_name, String var_order)
        throws TestFileException
    {
        String var_id = var_name == null ? null : var_name + ":" + var_order;
        TestCase tc = TestFactory.createTestCase();

        tc.setID(getJmppLib().test);
        if (var_id != null) {
            tc.setVarID(var_id);
        }
        tc.setTCDocumentation(createTCDocumentation(lib));
        tc.setCodeSet(createTCCodeSet(lib));
        return tc;
    }

    /**
     * Fills the attributes of given test case. The attributes are first collected
     * from all template parameters and then from the underlying Jmpp library.
     *
     * @param tc         the test case instance
     * @param all_params a list of the template parameters
     */
    protected void irFillTestCaseAttributes(TestCase tc, ArrayList all_params)
        throws TestFileException
    {
        tc.setTCAttributes(irCreateTestCaseAttributes());
    }

    protected TestCaseAttributes irCreateTestCaseAttributes() throws TestFileException {
        JmppLibTest jmpp_lib = getJmppLib();
        ArrayList specs = convertTargetSpecList(jmpp_lib.getTestcaseTargetSpec());
        ArrayList req_r = convertRequiredResources(jmpp_lib.getTestcaseRequiredResources());
        ArrayList attrs = convertAttrElems(jmpp_lib.getTestcaseAttrElems());

        TestCaseAttributes res = AttributesFactory.createTestCaseAttributes();

        if (specs != null) {
            res.setTargetSpecs(specs);
        }
        if (req_r != null) {
            res.setRequiredResources(req_r);
        }
        if (attrs != null) {
            res.setAttrElems(attrs);
        }
        IR.setAutoGeneratedAttrElem(res, "true");
        return res;
    }

    /**
     * Fills the attributes of given test group. The attributes are first collected
     * from all template parameters and then from the underlying Jmpp library.
     *
     * @param tg         the test group instance
     * @param all_params a list of the template parameters
     */
    protected void irFillTestGroupAttributes(TestGroup tg, ArrayList all_params)
        throws TestFileException
    {
        tg.setTGAttributes(createTGAttributes(getJmppLib()));
    }

    /**
     * @return default implementation of the <code>AttributeSet</code> interface
     *   for current test case - <code>TCAttributeSet</code> instance.
     *   Override in sub-classes when necessary.
     */
    protected AttributeSet createTCAttributeSet() {
        return new TCAttributeSet(getJmppLib());
    }

    /**
     * @return default implementation of the <code>AttributeSet</code> interface
     *   for current test group - <code>TGAttributeSet</code> instance.
     *   Override in sub-classes when necessary.
     */
    protected AttributeSet createTGAttributeSet() {
        return new TGAttributeSet(getJmppLib());
    }

    /**
     * Default implementation of the <code>AttributeSet</code> interface
     * for current test case. All calls are delegated to the complementary
     * Jmpp library instance (passed in the constructor), thus having
     * effect on current test case being generated by the library.
     */
    static class TCAttributeSet implements AttributeSet {
        private JmppLibTest lib;

        public TCAttributeSet(JmppLibTest lib) {
            this.lib = lib;
        }

        public void addTargetSpec(String id, String version) {
            lib.addTestcaseTargetSpec(id, version);
        }

        public void addTargetSpecElem(String id, String version, String name, String value) {
            lib.addTestcaseTargetSpecElem(id, version, name, value);
        }

        public void addRequiredResource(String name, String value) {
            lib.addTestcaseRequiredResource(name, value);
        }

        public void addAttrElem(String name, String value) {
            lib.addTestcaseAttrElem(name, value);
        }

        public void addTemplateAttribute(String name) {
            if (lib instanceof com.sun.jmpp.lib.JmppLibVM) {
                ((com.sun.jmpp.lib.JmppLibVM)lib).addTemplateAttribute(name);
            }
        }
    }

    /**
     * Default implementation of the <code>AttributeSet</code> interface
     * for current test group. All calls are delegated to the complementary
     * Jmpp library instance (passed in the constructor), thus having
     * effect on current test group being generated by the library.
     */
    static class TGAttributeSet implements AttributeSet {
        private JmppLibTest lib;

        public TGAttributeSet(JmppLibTest lib) {
            this.lib = lib;
        }

        public void addTargetSpec(String id, String version) {
            lib.addTestGroupTargetSpec(id, version);
        }

        public void addTargetSpecElem(String id, String version, String name, String value) {
            lib.addTestGroupTargetSpecElem(id, version, name, value);
        }

        public void addRequiredResource(String name, String value) {
            lib.addTestGroupRequiredResource(name, value);
        }

        public void addAttrElem(String name, String value) {
            lib.addTestGroupAttrElem(name, value);
        }
        
        public void addTemplateAttribute(String name) {
            throw new RuntimeException("The addTemplateAttribute(String attribute)"
                                       + " is not supported by TestGroup");
        }
    }
}
